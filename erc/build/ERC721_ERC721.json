{
    "functions": [
        {
            "def": "function balanceOf(address _owner) external view returns (uint256)",
            "raw_rules": "\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    ///  function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n",
            "format": {
                "name": "balanceOf",
                "arg_types": [
                    {
                        "name": "_owner",
                        "type": "address"
                    }
                ],
                "optional": null,
                "view": true,
                "pure": false,
                "payable": false,
                "return_type": {
                    "type": "uint256"
                }
            },
            "extracted": {
                "throw": [],
                "semantic_return": "The return value of the function `balanceOf(address _owner)` represents the total number of Non-Fungible Tokens (NFTs) that are currently owned by the specified address `_owner`. If the returned number is zero, it indicates that `_owner` does not possess any NFTs. This function is designed to provide a count of all valid NFTs linked to a particular owner, excluding any NFTs that might be erroneously assigned to an invalid address such as the zero address. Queries about the zero address will cause the function to throw an error, as NFTs assigned to the zero address are not considered valid.",
                "return": null,
                "emit": null,
                "assign": null,
                "call": null,
                "order": null
            },
            "extract_debug": {
                "throw": "```json\n[\n    {\n        \"if\": \"_owner is the zero address\",\n        \"throw\": true\n    }\n]\n```",
                "semantic_return": "The return value of the function `balanceOf(address _owner)` represents the total number of Non-Fungible Tokens (NFTs) that are currently owned by the specified address `_owner`. If the returned number is zero, it indicates that `_owner` does not possess any NFTs. This function is designed to provide a count of all valid NFTs linked to a particular owner, excluding any NFTs that might be erroneously assigned to an invalid address such as the zero address. Queries about the zero address will cause the function to throw an error, as NFTs assigned to the zero address are not considered valid."
            }
        },
        {
            "def": "function ownerOf(uint256 _tokenId) external view returns (address)",
            "raw_rules": "\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    ///  about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n",
            "format": {
                "name": "ownerOf",
                "arg_types": [
                    {
                        "name": "_tokenId",
                        "type": "uint256"
                    }
                ],
                "optional": null,
                "view": true,
                "pure": false,
                "payable": false,
                "return_type": {
                    "type": "address"
                }
            },
            "extracted": {
                "throw": [
                    {
                        "if": "NFTs assigned to zero address",
                        "throw": true
                    }
                ],
                "semantic_return": "The return value of the function `ownerOf(uint256 _tokenId)` is the Ethereum address that currently owns the specified NFT, identified by its unique token ID (`_tokenId`). If the NFT is assigned to the zero address, it is considered invalid, and the function will throw an error instead of returning an address.",
                "return": null,
                "emit": null,
                "assign": null,
                "call": null,
                "order": null
            },
            "extract_debug": {
                "throw": "```json\n[\n    {\n        \"if\": \"NFTs assigned to zero address\",\n        \"throw\": true\n    }\n]\n```",
                "semantic_return": "The return value of the function `ownerOf(uint256 _tokenId)` is the Ethereum address that currently owns the specified NFT, identified by its unique token ID (`_tokenId`). If the NFT is assigned to the zero address, it is considered invalid, and the function will throw an error instead of returning an address."
            }
        },
        {
            "def": "function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable",
            "raw_rules": "\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n    ///  `onERC721Received` on `_to` and throws if the return value is not\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n",
            "format": {
                "name": "safeTransferFrom",
                "arg_types": [
                    {
                        "name": "_from",
                        "type": "address"
                    },
                    {
                        "name": "_to",
                        "type": "address"
                    },
                    {
                        "name": "_tokenId",
                        "type": "uint256"
                    },
                    {
                        "name": "data",
                        "type": "bytes"
                    }
                ],
                "optional": null,
                "view": false,
                "pure": false,
                "payable": true,
                "return_type": null
            },
            "extracted": {
                "throw": [
                    {
                        "if": "`msg.sender` is not the current owner, an authorized operator, or the approved address for this NFT",
                        "throw": true
                    },
                    {
                        "if": "`_from` is not the current owner",
                        "throw": true
                    },
                    {
                        "if": "`_to` is the zero address",
                        "throw": true
                    },
                    {
                        "if": "`_tokenId` is not a valid NFT",
                        "throw": true
                    },
                    {
                        "if": "`_to` is a smart contract (code size > 0)",
                        "throw": false
                    },
                    {
                        "if": "the return value of `onERC721Received` is not `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`",
                        "throw": true
                    }
                ],
                "semantic_return": null,
                "return": null,
                "emit": [
                    {
                        "emit": [
                            "Transfer"
                        ],
                        "if": "`msg.sender` is the current owner, an authorized operator, or the approved address for this NFT, `_from` is the current owner, `_to` is not the zero address, and `_tokenId` is a valid NFT"
                    },
                    {
                        "emit": [
                            "Approval"
                        ],
                        "if": "the owner or an approved operator revokes approval for a token"
                    }
                ],
                "assign": [],
                "call": [
                    {
                        "call": "onERC721Received",
                        "if": "`_to` is a smart contract (code size > 0)",
                        "arg_rules": [
                            {
                                "arg": 1,
                                "rule": "`msg.sender` MUST be sent unaltered in call to the first argument"
                            },
                            {
                                "arg": 2,
                                "rule": "`_from` MUST be sent unaltered in call to the second argument"
                            },
                            {
                                "arg": 3,
                                "rule": "`_tokenId` MUST be sent unaltered in call to the third argument"
                            },
                            {
                                "arg": 4,
                                "rule": "`data` MUST be sent unaltered in call to the fourth argument"
                            }
                        ]
                    }
                ],
                "order": []
            },
            "extract_debug": {
                "throw": "```json\n[\n    {\n        \"if\": \"`msg.sender` is not the current owner, an authorized operator, or the approved address for this NFT\",\n        \"throw\": true\n    },\n    {\n        \"if\": \"`_from` is not the current owner\",\n        \"throw\": true\n    },\n    {\n        \"if\": \"`_to` is the zero address\",\n        \"throw\": true\n    },\n    {\n        \"if\": \"`_tokenId` is not a valid NFT\",\n        \"throw\": true\n    },\n    {\n        \"if\": \"`_to` is a smart contract (code size > 0)\",\n        \"throw\": false\n    },\n    {\n        \"if\": \"the return value of `onERC721Received` is not `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\",\n        \"throw\": true\n    }\n]\n```",
                "emit": "```json\n[\n    {\n        \"emit\": [\"Transfer\"],\n        \"if\": \"`msg.sender` is the current owner, an authorized operator, or the approved address for this NFT, `_from` is the current owner, `_to` is not the zero address, and `_tokenId` is a valid NFT\"\n    },\n    {\n        \"emit\": [\"Approval\"],\n        \"if\": \"the owner or an approved operator revokes approval for a token\"\n    }\n]\n```",
                "assign": "```json\n[]\n```",
                "call": "```json\n[\n    {\n        \"call\": \"onERC721Received\",\n        \"if\": \"`_to` is a smart contract (code size > 0)\",\n        \"arg_rules\": [\n            {\n                \"arg\": 1,\n                \"rule\": \"`msg.sender` MUST be sent unaltered in call to the first argument\"\n            },\n            {\n                \"arg\": 2,\n                \"rule\": \"`_from` MUST be sent unaltered in call to the second argument\"\n            },\n            {\n                \"arg\": 3,\n                \"rule\": \"`_tokenId` MUST be sent unaltered in call to the third argument\"\n            },\n            {\n                \"arg\": 4,\n                \"rule\": \"`data` MUST be sent unaltered in call to the fourth argument\"\n            }\n        ]\n    }\n]\n```",
                "order": "```json\n[]\n```"
            }
        },
        {
            "def": "function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable",
            "raw_rules": "\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    ///  except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n",
            "format": {
                "name": "safeTransferFrom",
                "arg_types": [
                    {
                        "name": "_from",
                        "type": "address"
                    },
                    {
                        "name": "_to",
                        "type": "address"
                    },
                    {
                        "name": "_tokenId",
                        "type": "uint256"
                    }
                ],
                "optional": null,
                "view": false,
                "pure": false,
                "payable": true,
                "return_type": null
            },
            "extracted": {
                "throw": [
                    {
                        "if": "`msg.sender` is not the current owner, an authorized operator, or the approved address for this NFT",
                        "throw": true
                    },
                    {
                        "if": "`_from` is not the current owner",
                        "throw": true
                    },
                    {
                        "if": "`_to` is the zero address",
                        "throw": true
                    },
                    {
                        "if": "`_tokenId` is not a valid NFT",
                        "throw": true
                    },
                    {
                        "if": "`_to` is a smart contract (code size > 0)",
                        "throw": false
                    },
                    {
                        "if": "the return value of `onERC721Received` is not `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`",
                        "throw": true
                    }
                ],
                "semantic_return": null,
                "return": null,
                "emit": [
                    {
                        "emit": [
                            "Transfer"
                        ],
                        "if": "`_from` is the current owner, an authorized operator, or the approved address for this NFT, `_to` is not the zero address, `_tokenId` is a valid NFT"
                    },
                    {
                        "emit": [
                            "Approval"
                        ],
                        "if": "the approved address for this NFT is reset (commonly to address(0))"
                    },
                    {
                        "emit": [
                            "ERC721Received"
                        ],
                        "if": "`_to` is a smart contract and `onERC721Received` is successfully called on `_to`"
                    }
                ],
                "assign": [],
                "call": [
                    {
                        "call": "onERC721Received",
                        "if": "`_to` is a smart contract (code size > 0)",
                        "arg_rules": [
                            {
                                "arg": 1,
                                "rule": "`msg.sender` MUST be sent unaltered in call to the first argument"
                            },
                            {
                                "arg": 2,
                                "rule": "`_from` MUST be sent unaltered in call to the second argument"
                            },
                            {
                                "arg": 3,
                                "rule": "`_to` MUST be sent unaltered in call to the third argument"
                            },
                            {
                                "arg": 4,
                                "rule": "`_tokenId` MUST be sent unaltered in call to the fourth argument"
                            },
                            {
                                "arg": 5,
                                "rule": "`data` MUST be sent unaltered in call to the fifth argument"
                            }
                        ]
                    }
                ],
                "order": []
            },
            "extract_debug": {
                "throw": "```json\n[\n    {\n        \"if\": \"`msg.sender` is not the current owner, an authorized operator, or the approved address for this NFT\",\n        \"throw\": true\n    },\n    {\n        \"if\": \"`_from` is not the current owner\",\n        \"throw\": true\n    },\n    {\n        \"if\": \"`_to` is the zero address\",\n        \"throw\": true\n    },\n    {\n        \"if\": \"`_tokenId` is not a valid NFT\",\n        \"throw\": true\n    },\n    {\n        \"if\": \"`_to` is a smart contract (code size > 0)\",\n        \"throw\": false\n    },\n    {\n        \"if\": \"the return value of `onERC721Received` is not `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\",\n        \"throw\": true\n    }\n]\n```",
                "emit": "```json\n[\n    {\n        \"emit\": [\"Transfer\"],\n        \"if\": \"`_from` is the current owner, an authorized operator, or the approved address for this NFT, `_to` is not the zero address, `_tokenId` is a valid NFT\"\n    },\n    {\n        \"emit\": [\"Approval\"],\n        \"if\": \"the approved address for this NFT is reset (commonly to address(0))\"\n    },\n    {\n        \"emit\": [\"ERC721Received\"],\n        \"if\": \"`_to` is a smart contract and `onERC721Received` is successfully called on `_to`\"\n    }\n]\n```",
                "assign": "```json\n[]\n```",
                "call": "```json\n[\n    {\n        \"call\": \"onERC721Received\",\n        \"if\": \"`_to` is a smart contract (code size > 0)\",\n        \"arg_rules\": [\n            {\n                \"arg\": 1,\n                \"rule\": \"`msg.sender` MUST be sent unaltered in call to the first argument\"\n            },\n            {\n                \"arg\": 2,\n                \"rule\": \"`_from` MUST be sent unaltered in call to the second argument\"\n            },\n            {\n                \"arg\": 3,\n                \"rule\": \"`_to` MUST be sent unaltered in call to the third argument\"\n            },\n            {\n                \"arg\": 4,\n                \"rule\": \"`_tokenId` MUST be sent unaltered in call to the fourth argument\"\n            },\n            {\n                \"arg\": 5,\n                \"rule\": \"`data` MUST be sent unaltered in call to the fifth argument\"\n            }\n        ]\n    }\n]\n```",
                "order": "The provided function description for `safeTransferFrom` does not explicitly mention any conditions that must follow a specific order based on an array parameter or any other sequence-based parameter. The description primarily outlines conditions and checks that must be met for the function to execute successfully, but these are not described as needing to follow the order of a specific parameter.\n\nGiven this, the appropriate JSON response indicating no order-based conditions found in the description would be an empty array:\n\n```json\n[]\n```"
            }
        },
        {
            "def": "function transferFrom(address _from, address _to, uint256 _tokenId) external payable",
            "raw_rules": "\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    ///  THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n",
            "format": {
                "name": "transferFrom",
                "arg_types": [
                    {
                        "name": "_from",
                        "type": "address"
                    },
                    {
                        "name": "_to",
                        "type": "address"
                    },
                    {
                        "name": "_tokenId",
                        "type": "uint256"
                    }
                ],
                "optional": null,
                "view": false,
                "pure": false,
                "payable": true,
                "return_type": null
            },
            "extracted": {
                "throw": [
                    {
                        "if": "`msg.sender` is not the current owner, an authorized operator, or the approved address for this NFT",
                        "throw": true
                    },
                    {
                        "if": "`_from` is not the current owner",
                        "throw": true
                    },
                    {
                        "if": "`_to` is the zero address",
                        "throw": true
                    },
                    {
                        "if": "`_tokenId` is not a valid NFT",
                        "throw": true
                    }
                ],
                "semantic_return": null,
                "return": null,
                "emit": [
                    {
                        "emit": [
                            "Transfer"
                        ],
                        "if": "msg.sender is the current owner, an authorized operator, or the approved address for this NFT, `_from` is the current owner, `_to` is not the zero address, and `_tokenId` is a valid NFT"
                    }
                ],
                "assign": [],
                "call": [],
                "order": []
            },
            "extract_debug": {
                "throw": "```json\n[\n    {\n        \"if\": \"`msg.sender` is not the current owner, an authorized operator, or the approved address for this NFT\",\n        \"throw\": true\n    },\n    {\n        \"if\": \"`_from` is not the current owner\",\n        \"throw\": true\n    },\n    {\n        \"if\": \"`_to` is the zero address\",\n        \"throw\": true\n    },\n    {\n        \"if\": \"`_tokenId` is not a valid NFT\",\n        \"throw\": true\n    }\n]\n```",
                "emit": "Based on the provided function description and the typical patterns for event emission in smart contracts, it appears that the function `transferFrom` does not explicitly state the emission of any events within the provided comment block. However, in common implementations of such functions (especially in standards like ERC-721 for NFTs), events such as `Transfer` are typically emitted to log the change of ownership of an asset.\n\nAssuming the standard behavior of NFT contracts and the typical event associated with a transfer operation, we can infer the likely event and conditions under which it would be emitted. The standard `Transfer` event in NFT contracts (following ERC-721) is emitted when an NFT is successfully transferred from one address to another. The conditions for this event typically include successful validation of all the requirements for a transfer, as outlined in the comments (e.g., sender authorization, valid ownership, non-zero recipient, etc.).\n\nGiven this, the JSON representation of the conditions under which the `Transfer` event is likely emitted would be:\n\n```json\n[\n    {\n        \"emit\": [\"Transfer\"],\n        \"if\": \"msg.sender is the current owner, an authorized operator, or the approved address for this NFT, `_from` is the current owner, `_to` is not the zero address, and `_tokenId` is a valid NFT\"\n    }\n]\n```\n\nThis JSON assumes the typical behavior of emitting a `Transfer` event upon successful validation and execution of the `transferFrom` function, even though the specific event emission is not explicitly mentioned in the provided function documentation.",
                "assign": "[]",
                "call": "[]",
                "order": "```json\n[]\n```"
            }
        },
        {
            "def": "function approve(address _approved, uint256 _tokenId) external payable",
            "raw_rules": "\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n",
            "format": {
                "name": "approve",
                "arg_types": [
                    {
                        "name": "_approved",
                        "type": "address"
                    },
                    {
                        "name": "_tokenId",
                        "type": "uint256"
                    }
                ],
                "optional": null,
                "view": false,
                "pure": false,
                "payable": true,
                "return_type": null
            },
            "extracted": {
                "throw": [
                    {
                        "if": "`msg.sender` is not the current NFT owner and not an authorized operator of the current owner",
                        "throw": true
                    }
                ],
                "semantic_return": null,
                "return": null,
                "emit": [
                    {
                        "emit": [
                            "Approval"
                        ]
                    }
                ],
                "assign": [],
                "call": [],
                "order": []
            },
            "extract_debug": {
                "throw": "```json\n[\n    {\n        \"if\": \"`msg.sender` is not the current NFT owner and not an authorized operator of the current owner\",\n        \"throw\": true\n    }\n]\n```",
                "emit": "Based on the provided function documentation and the typical behavior of an `approve` function in the context of NFTs (Non-Fungible Tokens), the function is likely to emit an event when the approval status of an NFT is changed. However, the specific event name and conditions are not explicitly mentioned in the provided documentation snippet. Commonly, in ERC-721 (a standard for representing ownership of non-fungible tokens), an `Approval` event is emitted when the approval status of an NFT changes.\n\nAssuming the standard behavior of the ERC-721 `approve` function, the conditions for emitting an event would typically include successfully changing the approved address for a token. The condition for this event generally involves the function being called by either the current owner of the token or an authorized operator. Here is how this might be represented in JSON format, assuming the event name is `Approval` based on common practice:\n\n```json\n[\n    {\n        \"emit\": [\"Approval\"],\n        \"if\": \"`msg.sender` is the current NFT owner or an authorized operator of the current owner\"\n    }\n]\n```\n\nThis JSON representation assumes the typical behavior of emitting an `Approval` event under the condition that the caller (`msg.sender`) has the authority to change the approval status, which aligns with the rules mentioned in the function documentation. If there are additional events or different conditions, they would need to be specified in the function's detailed documentation or source code.",
                "assign": "[]",
                "call": "[]",
                "order": "The provided function description and the request for \"order\" rules do not explicitly mention any array parameters or a sequence that must be followed based on an array parameter. The function `approve(address _approved, uint256 _tokenId)` does not include any array-type parameters that would typically necessitate an ordering condition as described. Therefore, based on the information given and the nature of the function parameters, there are no \"order\" conditions relevant to array parameters to list. Here is the JSON response reflecting this:\n\n```json\n[]\n```"
            }
        },
        {
            "def": "function setApprovalForAll(address _operator, bool _approved) external",
            "raw_rules": "\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    ///  multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n",
            "format": {
                "name": "setApprovalForAll",
                "arg_types": [
                    {
                        "name": "_operator",
                        "type": "address"
                    },
                    {
                        "name": "_approved",
                        "type": "bool"
                    }
                ],
                "optional": null,
                "view": false,
                "pure": false,
                "payable": false,
                "return_type": null
            },
            "extracted": {
                "throw": [],
                "semantic_return": null,
                "return": null,
                "emit": [
                    {
                        "emit": [
                            "ApprovalForAll"
                        ],
                        "if": "always"
                    }
                ],
                "assign": [],
                "call": [],
                "order": []
            },
            "extract_debug": {
                "throw": "```json\n[]\n```",
                "emit": "```json\n[\n    {\n        \"emit\": [\"ApprovalForAll\"],\n        \"if\": \"always\"\n    }\n]\n```",
                "assign": "```json\n[]\n```",
                "call": "[]",
                "order": "```json\n[]\n```"
            }
        },
        {
            "def": "function getApproved(uint256 _tokenId) external view returns (address)",
            "raw_rules": "\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n",
            "format": {
                "name": "getApproved",
                "arg_types": [
                    {
                        "name": "_tokenId",
                        "type": "uint256"
                    }
                ],
                "optional": null,
                "view": true,
                "pure": false,
                "payable": false,
                "return_type": {
                    "type": "address"
                }
            },
            "extracted": {
                "throw": [
                    {
                        "if": "_tokenId is not a valid NFT",
                        "throw": true
                    }
                ],
                "semantic_return": "The function `getApproved(uint256 _tokenId)` returns the address that has been authorized to manage a specific non-fungible token (NFT) identified by `_tokenId`. If no address has been authorized for this particular NFT, the function will return a special value known as the zero address, which effectively means that no approval has been granted. This function is used to check which address, if any, has the permission to handle transactions involving the specified NFT, such as transferring it.",
                "return": null,
                "emit": null,
                "assign": null,
                "call": null,
                "order": null
            },
            "extract_debug": {
                "throw": "```json\n[\n    {\n        \"if\": \"_tokenId is not a valid NFT\",\n        \"throw\": true\n    }\n]\n```",
                "semantic_return": "The function `getApproved(uint256 _tokenId)` returns the address that has been authorized to manage a specific non-fungible token (NFT) identified by `_tokenId`. If no address has been authorized for this particular NFT, the function will return a special value known as the zero address, which effectively means that no approval has been granted. This function is used to check which address, if any, has the permission to handle transactions involving the specified NFT, such as transferring it."
            }
        },
        {
            "def": "function isApprovedForAll(address _owner, address _operator) external view returns (bool)",
            "raw_rules": "\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n",
            "format": {
                "name": "isApprovedForAll",
                "arg_types": [
                    {
                        "name": "_owner",
                        "type": "address"
                    },
                    {
                        "name": "_operator",
                        "type": "address"
                    }
                ],
                "optional": null,
                "view": true,
                "pure": false,
                "payable": false,
                "return_type": {
                    "type": "bool"
                }
            },
            "extracted": {
                "throw": [],
                "semantic_return": "The function `isApprovedForAll(address _owner, address _operator)` checks if a specific address, referred to as `_operator`, is authorized to manage all non-fungible tokens (NFTs) owned by another address, `_owner`. The function returns a boolean value: `true` if the `_operator` is indeed authorized to act on behalf of the `_owner` for all their NFTs, and `false` if the `_operator` does not have such authorization.",
                "return": [],
                "emit": null,
                "assign": null,
                "call": null,
                "order": null
            },
            "extract_debug": {
                "throw": "```json\n[]\n```",
                "semantic_return": "The function `isApprovedForAll(address _owner, address _operator)` checks if a specific address, referred to as `_operator`, is authorized to manage all non-fungible tokens (NFTs) owned by another address, `_owner`. The function returns a boolean value: `true` if the `_operator` is indeed authorized to act on behalf of the `_owner` for all their NFTs, and `false` if the `_operator` does not have such authorization.",
                "return": "```json\n[]\n```"
            }
        }
    ],
    "events": [
        {
            "def": "event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);",
            "raw_rules": "    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n    ///  may be created and assigned without emitting Transfer. At the time of\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n",
            "format": {
                "name": "Transfer",
                "arg_types": [
                    {
                        "name": "_from",
                        "type": "address",
                        "indexed": true
                    },
                    {
                        "name": "_to",
                        "type": "address",
                        "indexed": true
                    },
                    {
                        "name": "_tokenId",
                        "type": "uint256",
                        "indexed": true
                    }
                ]
            },
            "extracted": {
                "emit": [
                    {
                        "if": "ownership of any NFT changes by any mechanism",
                        "arg_rules": [],
                        "emit": [
                            "Transfer"
                        ]
                    },
                    {
                        "if": "NFTs are created",
                        "arg_rules": [
                            {
                                "arg": 0,
                                "rule": "_from MUST be 0"
                            }
                        ],
                        "emit": [
                            "Transfer"
                        ]
                    },
                    {
                        "if": "NFTs are destroyed",
                        "arg_rules": [
                            {
                                "arg": 1,
                                "rule": "_to MUST be 0"
                            }
                        ],
                        "emit": [
                            "Transfer"
                        ]
                    },
                    {
                        "if": "during contract creation, any number of NFTs may be created and assigned",
                        "arg_rules": [],
                        "emit": []
                    }
                ],
                "assign": [
                    "the approved address for that NFT (if any) is reset to none"
                ]
            },
            "extract_debug": {
                "emit": "```json\n[\n    {\n        \"if\": \"ownership of any NFT changes by any mechanism\",\n        \"arg_rules\": [],\n        \"emit\": [\"Transfer\"]\n    },\n    {\n        \"if\": \"NFTs are created\",\n        \"arg_rules\": [\n            {\n                \"arg\": 0,\n                \"rule\": \"_from MUST be 0\"\n            }\n        ],\n        \"emit\": [\"Transfer\"]\n    },\n    {\n        \"if\": \"NFTs are destroyed\",\n        \"arg_rules\": [\n            {\n                \"arg\": 1,\n                \"rule\": \"_to MUST be 0\"\n            }\n        ],\n        \"emit\": [\"Transfer\"]\n    },\n    {\n        \"if\": \"during contract creation, any number of NFTs may be created and assigned\",\n        \"arg_rules\": [],\n        \"emit\": []\n    },\n    {\n        \"if\": \"at the time of any transfer\",\n        \"arg_rules\": [\n            {\n                \"arg\": 2,\n                \"rule\": \"the approved address for that NFT (if any) is reset to none\"\n            }\n        ],\n        \"emit\": [\"Transfer\"]\n    }\n]\n```",
                "assign": "```json\n[\n    \"the approved address for that NFT (if any) is reset to none\"\n]\n```"
            }
        },
        {
            "def": "event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);",
            "raw_rules": "\n    /// @dev This emits when the approved address for an NFT is changed or\n    ///  reaffirmed. The zero address indicates there is no approved address.\n    ///  When a Transfer event emits, this also indicates that the approved\n    ///  address for that NFT (if any) is reset to none.\n",
            "format": {
                "name": "Approval",
                "arg_types": [
                    {
                        "name": "_owner",
                        "type": "address",
                        "indexed": true
                    },
                    {
                        "name": "_approved",
                        "type": "address",
                        "indexed": true
                    },
                    {
                        "name": "_tokenId",
                        "type": "uint256",
                        "indexed": true
                    }
                ]
            },
            "extracted": {
                "emit": [
                    {
                        "if": "the approved address for an NFT is changed or reaffirmed",
                        "arg_rules": [
                            {
                                "arg": 1,
                                "rule": "The argument _approved MUST be the new approved address or zero address indicating no approved address."
                            }
                        ],
                        "emit": [
                            "Approval"
                        ]
                    },
                    {
                        "if": "a Transfer event emits",
                        "arg_rules": [
                            {
                                "arg": 1,
                                "rule": "The argument _approved MUST be set to none."
                            }
                        ],
                        "emit": [
                            "Approval"
                        ]
                    }
                ],
                "assign": [
                    "the approved address for that NFT is reset to none"
                ]
            },
            "extract_debug": {
                "emit": "```json\n[\n    {\n        \"if\": \"the approved address for an NFT is changed or reaffirmed\",\n        \"arg_rules\": [\n            {\n                \"arg\": 1,\n                \"rule\": \"The argument _approved MUST be the new approved address or zero address indicating no approved address.\"\n            }\n        ],\n        \"emit\": [\"Approval\"]\n    },\n    {\n        \"if\": \"a Transfer event emits\",\n        \"arg_rules\": [\n            {\n                \"arg\": 1,\n                \"rule\": \"The argument _approved MUST be set to none.\"\n            }\n        ],\n        \"emit\": [\"Approval\"]\n    }\n]\n```",
                "assign": "```json\n[\n    \"the approved address for that NFT is reset to none\"\n]\n```"
            }
        },
        {
            "def": "event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);",
            "raw_rules": "\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    ///  The operator can manage all NFTs of the owner.\n",
            "format": {
                "name": "ApprovalForAll",
                "arg_types": [
                    {
                        "name": "_owner",
                        "type": "address",
                        "indexed": true
                    },
                    {
                        "name": "_operator",
                        "type": "address",
                        "indexed": true
                    },
                    {
                        "name": "_approved",
                        "type": "bool",
                        "indexed": false
                    }
                ]
            },
            "extracted": {
                "emit": [
                    {
                        "if": "an operator is enabled or disabled for an owner",
                        "arg_rules": [
                            {
                                "arg": 0,
                                "rule": "The argument _owner MUST be the address of the NFT owner"
                            },
                            {
                                "arg": 1,
                                "rule": "The argument _operator MUST be the address of the operator"
                            },
                            {
                                "arg": 2,
                                "rule": "The argument _approved MUST be set to true if the operator is enabled, false if disabled"
                            }
                        ],
                        "emit": [
                            "ApprovalForAll"
                        ]
                    }
                ],
                "assign": []
            },
            "extract_debug": {
                "emit": "```json\n[\n    {\n        \"if\": \"an operator is enabled or disabled for an owner\",\n        \"arg_rules\": [\n            {\n                \"arg\": 0,\n                \"rule\": \"The argument _owner MUST be the address of the NFT owner\"\n            },\n            {\n                \"arg\": 1,\n                \"rule\": \"The argument _operator MUST be the address of the operator\"\n            },\n            {\n                \"arg\": 2,\n                \"rule\": \"The argument _approved MUST be set to true if the operator is enabled, false if disabled\"\n            }\n        ],\n        \"emit\": [\"ApprovalForAll\"]\n    }\n]\n```",
                "assign": "[]"
            }
        }
    ],
    "name": "ERC721",
    "rules": [
        {
            "rule": "The return value of the function `balanceOf(address _owner)` represents the total number of Non-Fungible Tokens (NFTs) that are currently owned by the specified address `_owner`. If the returned number is zero, it indicates that `_owner` does not possess any NFTs. This function is designed to provide a count of all valid NFTs linked to a particular owner, excluding any NFTs that might be erroneously assigned to an invalid address such as the zero address. Queries about the zero address will cause the function to throw an error, as NFTs assigned to the zero address are not considered valid.",
            "type": "semantic_return",
            "interface": "function balanceOf(address _owner) external view returns (uint256)"
        },
        {
            "rule": " throw if _owner is the zero address",
            "type": "throw",
            "interface": "function balanceOf(address _owner) external view returns (uint256)",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "CompCondition",
                        "left": {
                            "type": "FuncParamSelector",
                            "index": 0
                        },
                        "right": {
                            "type": "ConstantSelector",
                            "value": "0x0000000000000000000000000000000000000000"
                        },
                        "op": "eq"
                    },
                    "op": "throw"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification of the function `balanceOf(address _owner)`, we need to ensure that the function throws an error if `_owner` is the zero address. This can be represented in the JSON schema by using a `ThrowVerify` object with a `CompCondition` that checks if `_owner` is equal to the zero address.\n\nHere is the JSON configuration for the rule:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"CompCondition\",\n            \"left\": {\n                \"type\": \"FuncParamSelector\",\n                \"index\": 0\n            },\n            \"right\": {\n                \"type\": \"ConstantSelector\",\n                \"value\": \"0x0000000000000000000000000000000000000000\"\n            },\n            \"op\": \"eq\"\n        },\n        \"op\": \"throw\"\n    }\n}\n```\n\nExplanation:\n- **ThrowVerify**: This object specifies that we are setting a condition for throwing an exception.\n- **cond**: This is the condition under which the throw will occur.\n  - **type**: \"CompCondition\" indicates a comparison condition.\n  - **left**: This selects the first function parameter (`_owner`), which is at index 0.\n  - **right**: This is a constant selector that specifies the zero address (`0x0000000000000000000000000000000000000000`).\n  - **op**: \"eq\" specifies that the operation is an equality check.\n- **op**: \"throw\" specifies that the operation should result in a throw if the condition is true.\n\nThis configuration ensures that the `balanceOf` function will throw an exception if the `_owner` parameter is the zero address, adhering to the specified rule."
        },
        {
            "rule": "The return value of the function `ownerOf(uint256 _tokenId)` is the Ethereum address that currently owns the specified NFT, identified by its unique token ID (`_tokenId`). If the NFT is assigned to the zero address, it is considered invalid, and the function will throw an error instead of returning an address.",
            "type": "semantic_return",
            "interface": "function ownerOf(uint256 _tokenId) external view returns (address)"
        },
        {
            "rule": " throw if NFTs assigned to zero address",
            "type": "throw",
            "interface": "function ownerOf(uint256 _tokenId) external view returns (address)",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "CompCondition",
                        "left": {
                            "type": "StateVarSelector",
                            "anchor_fn": "ownerOf",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 0
                                }
                            ]
                        },
                        "right": {
                            "type": "ConstantSelector",
                            "value": "0x0000000000000000000000000000000000000000"
                        },
                        "op": "eq"
                    },
                    "op": "throw"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification that ensures the `ownerOf` function throws if an NFT is assigned to the zero address, we need to define a condition that checks if the result of the `ownerOf` function is equal to the zero address (typically represented as `0x0000000000000000000000000000000000000000` in Ethereum). If this condition is true, the function should throw an error.\n\nHere's the JSON configuration for this rule:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"CompCondition\",\n            \"left\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"ownerOf\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 0\n                    }\n                ]\n            },\n            \"right\": {\n                \"type\": \"ConstantSelector\",\n                \"value\": \"0x0000000000000000000000000000000000000000\"\n            },\n            \"op\": \"eq\"\n        },\n        \"op\": \"throw\"\n    }\n}\n```\n\nExplanation:\n1. **ThrowVerify**: This is the main object that specifies the type of verification (throwing an error under certain conditions).\n2. **cond**: This defines the condition under which the error should be thrown.\n   - **CompCondition**: This specifies a comparison condition.\n   - **left**: This selects the state variable `_owners` from the `ownerOf` function, indexed by the function's parameter (`_tokenId`).\n   - **right**: This is a constant selector that specifies the zero address.\n   - **op**: The operation `eq` checks for equality between the left and right values.\n3. **op**: Specifies that the function should `throw` an error if the condition is met.\n\nThis configuration ensures that if the `ownerOf` function tries to return the zero address for any token ID, it will throw an error, enforcing the rule that NFTs must not be assigned to the zero address."
        },
        {
            "rule": " throw if `msg.sender` is not the current owner, an authorized operator, or the approved address for this NFT",
            "type": "throw",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "LogicCondition",
                        "cond": [
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "MsgSenderSelector"
                                },
                                "right": {
                                    "type": "StateVarSelector",
                                    "anchor_fn": "ownerOf",
                                    "keys": [
                                        {
                                            "type": "FuncParamSelector",
                                            "index": 2
                                        }
                                    ]
                                },
                                "op": "eq"
                            },
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "MsgSenderSelector"
                                },
                                "right": {
                                    "type": "StateVarSelector",
                                    "anchor_fn": "getApproved",
                                    "keys": [
                                        {
                                            "type": "FuncParamSelector",
                                            "index": 2
                                        }
                                    ]
                                },
                                "op": "eq"
                            },
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "StateVarSelector",
                                    "anchor_fn": "isApprovedForAll",
                                    "keys": [
                                        {
                                            "type": "StateVarSelector",
                                            "anchor_fn": "ownerOf",
                                            "keys": [
                                                {
                                                    "type": "FuncParamSelector",
                                                    "index": 2
                                                }
                                            ]
                                        },
                                        {
                                            "type": "MsgSenderSelector"
                                        }
                                    ]
                                },
                                "right": {
                                    "type": "ConstantSelector",
                                    "value": true
                                },
                                "op": "eq"
                            }
                        ],
                        "op": "or"
                    },
                    "op": "not_throw"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification, we need to construct a condition that checks if `msg.sender` is either the current owner, an authorized operator, or the approved address for the NFT. We will use the anchor functions `ownerOf`, `getApproved`, and `isApprovedForAll` to retrieve the necessary state variables.\n\nHere's the JSON configuration for the rule verification:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"LogicCondition\",\n            \"cond\": [\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"MsgSenderSelector\"\n                    },\n                    \"right\": {\n                        \"type\": \"StateVarSelector\",\n                        \"anchor_fn\": \"ownerOf\",\n                        \"keys\": [\n                            {\n                                \"type\": \"FuncParamSelector\",\n                                \"index\": 2\n                            }\n                        ]\n                    },\n                    \"op\": \"eq\"\n                },\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"MsgSenderSelector\"\n                    },\n                    \"right\": {\n                        \"type\": \"StateVarSelector\",\n                        \"anchor_fn\": \"getApproved\",\n                        \"keys\": [\n                            {\n                                \"type\": \"FuncParamSelector\",\n                                \"index\": 2\n                            }\n                        ]\n                    },\n                    \"op\": \"eq\"\n                },\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"StateVarSelector\",\n                        \"anchor_fn\": \"isApprovedForAll\",\n                        \"keys\": [\n                            {\n                                \"type\": \"StateVarSelector\",\n                                \"anchor_fn\": \"ownerOf\",\n                                \"keys\": [\n                                    {\n                                        \"type\": \"FuncParamSelector\",\n                                        \"index\": 2\n                                    }\n                                ]\n                            },\n                            {\n                                \"type\": \"MsgSenderSelector\"\n                            }\n                        ]\n                    },\n                    \"right\": {\n                        \"type\": \"ConstantSelector\",\n                        \"value\": true\n                    },\n                    \"op\": \"eq\"\n                }\n            ],\n            \"op\": \"or\"\n        },\n        \"op\": \"not_throw\"\n    }\n}\n```\n\nExplanation:\n1. **Owner Check**: The first condition checks if `msg.sender` is equal to the owner of the token (retrieved using `ownerOf` function with the token ID as the key).\n2. **Approved Address Check**: The second condition checks if `msg.sender` is the approved address for the token (retrieved using `getApproved` function with the token ID as the key).\n3. **Operator Approval Check**: The third condition checks if `msg.sender` is an authorized operator for the owner of the token. This involves checking if the operator approval mapping (retrieved using `isApprovedForAll`) for the owner (retrieved using `ownerOf` with the token ID) and `msg.sender` is set to true.\n4. **Logical OR**: The conditions are combined using a logical OR, meaning if any of the conditions are true, the function should not throw.\n\nThis configuration ensures that the function will throw an error if none of the conditions are met, adhering to the specified rule."
        },
        {
            "rule": " throw if `_from` is not the current owner",
            "type": "throw",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "CompCondition",
                        "left": {
                            "type": "FuncParamSelector",
                            "index": 0
                        },
                        "right": {
                            "type": "StateVarSelector",
                            "anchor_fn": "ownerOf",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 2
                                }
                            ]
                        },
                        "op": "not_eq"
                    },
                    "op": "throw"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification that throws if `_from` is not the current owner in the `safeTransferFrom` function, we need to use the `ownerOf` function as the anchor function. This function uses the `_owners` mapping to determine the owner of a specific token ID. The rule should verify that the address provided in the `_from` parameter of `safeTransferFrom` matches the owner address returned by `ownerOf` for the given `_tokenId`.\n\nHere is the JSON configuration for this rule:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"CompCondition\",\n            \"left\": {\n                \"type\": \"FuncParamSelector\",\n                \"index\": 0\n            },\n            \"right\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"ownerOf\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 2\n                    }\n                ]\n            },\n            \"op\": \"not_eq\"\n        },\n        \"op\": \"throw\"\n    }\n}\n```\n\nExplanation:\n- **ThrowVerify**: This object specifies that the condition should result in a throw if not met.\n- **cond**: This is the condition that needs to be met to avoid throwing. It is a comparison condition.\n- **CompCondition**: Specifies that this is a comparison condition.\n- **left**: This selects the first function parameter (`_from`) of `safeTransferFrom`.\n- **right**: This selects the state variable using the `ownerOf` function, which returns the owner of the token ID specified by the third parameter (`_tokenId`) of `safeTransferFrom`.\n- **op**: The operation `not_eq` specifies that the rule should throw if the left side (address from `_from`) is not equal to the right side (owner address from `ownerOf`).\n- **op** in `ThrowVerify`: Specifies that the operation should result in a throw if the condition is true (i.e., if `_from` is not the current owner).\n\nThis configuration ensures that the smart contract throws an error if the `_from` address in the `safeTransferFrom` function does not match the current owner of the token as per the `ownerOf` function, enforcing the rule correctly."
        },
        {
            "rule": " throw if `_to` is the zero address",
            "type": "throw",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "CompCondition",
                        "left": {
                            "type": "FuncParamSelector",
                            "index": 1
                        },
                        "right": {
                            "type": "ConstantSelector",
                            "value": "0x0000000000000000000000000000000000000000"
                        },
                        "op": "eq"
                    },
                    "op": "throw"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification that throws if `_to` is the zero address in the function `safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data)`, we need to define a condition that checks if the `_to` parameter is equal to the zero address (typically represented as `0x0000000000000000000000000000000000000000` in Ethereum).\n\nHere's the JSON configuration based on the provided schema:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"CompCondition\",\n            \"left\": {\n                \"type\": \"FuncParamSelector\",\n                \"index\": 1\n            },\n            \"right\": {\n                \"type\": \"ConstantSelector\",\n                \"value\": \"0x0000000000000000000000000000000000000000\"\n            },\n            \"op\": \"eq\"\n        },\n        \"op\": \"throw\"\n    }\n}\n```\n\nExplanation:\n- **ThrowVerify**: This object specifies that we are setting up a condition to throw an exception.\n- **cond**: This is the condition under which the throw will occur.\n  - **type**: \"CompCondition\" indicates a comparison condition.\n  - **left**: This selects the second parameter of the function (`_to`), which is at index 1 (indexing starts from 0).\n  - **right**: This is a constant selector that specifies the zero address.\n  - **op**: \"eq\" stands for \"equals\", so the condition checks if `_to` equals the zero address.\n- **op**: \"throw\" specifies that the operation should throw an exception if the condition is true.\n\nThis JSON configuration ensures that the `safeTransferFrom` function will throw an exception if the `_to` address is the zero address, adhering to the specified rule."
        },
        {
            "rule": " throw if `_tokenId` is not a valid NFT",
            "type": "throw",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "CompCondition",
                        "left": {
                            "type": "StateVarSelector",
                            "anchor_fn": "ownerOf",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 2
                                }
                            ]
                        },
                        "right": {
                            "type": "ConstantSelector",
                            "value": "0x0000000000000000000000000000000000000000"
                        },
                        "op": "eq"
                    },
                    "op": "throw"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification that throws if `_tokenId` is not a valid NFT, we need to check if the `_tokenId` is associated with an owner in the `_owners` mapping. This can be done by verifying that the owner address is not the zero address (indicating no owner).\n\nGiven the function `safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data)`, the `_tokenId` is the third parameter (index 2 when starting from 0). We will use the `ownerOf` function's state variable `_owners` to check if the `_tokenId` has a valid owner.\n\nHere is the JSON configuration for this rule:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"CompCondition\",\n            \"left\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"ownerOf\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 2\n                    }\n                ]\n            },\n            \"right\": {\n                \"type\": \"ConstantSelector\",\n                \"value\": \"0x0000000000000000000000000000000000000000\"\n            },\n            \"op\": \"eq\"\n        },\n        \"op\": \"throw\"\n    }\n}\n```\n\nExplanation:\n- **ThrowVerify**: This object specifies that the condition inside it should lead to a throw if true.\n- **cond**: This is the condition that needs to be checked.\n  - **CompCondition**: This specifies a comparison condition.\n  - **left**: This selects the owner of the `_tokenId` using the `StateVarSelector` which is linked to the `ownerOf` function's state variable `_owners`. The `keys` array specifies that we are interested in the owner of the token ID passed as the third parameter (`index: 2`) of the `safeTransferFrom` function.\n  - **right**: This is a constant selector specifying the zero address. In Ethereum, the zero address typically indicates an uninitialized or invalid state.\n  - **op**: The operation `eq` checks for equality between the left and right values.\n- **op**: The operation `throw` specifies that the function should throw if the condition is true, i.e., if the owner of the token ID is the zero address, indicating that the `_tokenId` is not valid.\n\nThis JSON configuration ensures that the `safeTransferFrom` function will throw an error if an attempt is made to transfer a non-existent or invalid NFT, as identified by the zero address in the `_owners` mapping."
        },
        {
            "rule": " throw if the return value of `onERC721Received` is not `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`",
            "type": "throw",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable",
            "sym_debug": "To generate the JSON configuration for the rule verification, we need to define a `ThrowVerify` object that checks if the return value of the `onERC721Received` function call is not equal to the expected constant value `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`. This involves using a `CompCondition` to compare the return value of the function call with the constant value.\n\nHere is the JSON configuration for the rule verification:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"CompCondition\",\n            \"left\": {\n                \"type\": \"FnCallRetSelector\",\n                \"fn_name\": \"onERC721Received\"\n            },\n            \"right\": {\n                \"type\": \"ConstantSelector\",\n                \"value\": \"0x150b7a02\"  // This is the bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n            },\n            \"op\": \"not_eq\"\n        },\n        \"op\": \"throw\"\n    }\n}\n```\n\nExplanation:\n- **ThrowVerify**: This object specifies that a condition should be checked, and if the condition is true, a throw (revert) should occur.\n- **cond**: This is the condition that needs to be checked. It is a comparison condition (`CompCondition`).\n- **left**: The left side of the comparison is the return value of the `onERC721Received` function call, selected using `FnCallRetSelector`.\n- **right**: The right side of the comparison is the constant value `0x150b7a02`, which is the expected return value for the `onERC721Received` function, represented as a `ConstantSelector`.\n- **op**: The operation for the comparison is `not_eq`, meaning the condition checks if the left side is not equal to the right side.\n- **op** in `ThrowVerify`: Specifies that the operation is a `throw`, meaning the transaction should revert if the condition is true.\n\nThis configuration ensures that the smart contract adheres to the ERC-721 standard by verifying that the `onERC721Received` function returns the correct acknowledgment when a token is safely transferred. If the function does not return the expected value, the transaction will revert, preventing the token transfer.",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "CompCondition",
                        "left": {
                            "type": "FnCallRetSelector",
                            "fn_name": "onERC721Received"
                        },
                        "right": {
                            "type": "ConstantSelector",
                            "value": "0x150b7a02"
                        },
                        "op": "not_eq"
                    },
                    "op": "throw"
                }
            }
        },
        {
            "rule": "emit '['Transfer']' if `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT, `_from` is the current owner, `_to` is not the zero address, and `_tokenId` is a valid NFT",
            "type": "emit",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable",
            "sym": {
                "EmitVerify": {
                    "event": "Transfer",
                    "sv_cond": {
                        "type": "WrittenCondition",
                        "value": {
                            "type": "StateVarSelector",
                            "anchor_fn": "ownerOf",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 2
                                }
                            ]
                        }
                    },
                    "cond": {
                        "type": "LogicCondition",
                        "op": "and",
                        "conds": [
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "FuncParamSelector",
                                    "index": 1
                                },
                                "right": {
                                    "type": "StateVarSelector",
                                    "anchor_fn": "ownerOf",
                                    "keys": [
                                        {
                                            "type": "FuncParamSelector",
                                            "index": 2
                                        }
                                    ]
                                },
                                "op": "eq"
                            },
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "FuncParamSelector",
                                    "index": 1
                                },
                                "right": {
                                    "type": "ConstantSelector",
                                    "value": "0x0000000000000000000000000000000000000000"
                                },
                                "op": "not_eq"
                            },
                            {
                                "type": "LogicCondition",
                                "op": "or",
                                "conds": [
                                    {
                                        "type": "CompCondition",
                                        "left": {
                                            "type": "MsgSenderSelector"
                                        },
                                        "right": {
                                            "type": "StateVarSelector",
                                            "anchor_fn": "ownerOf",
                                            "keys": [
                                                {
                                                    "type": "FuncParamSelector",
                                                    "index": 2
                                                }
                                            ]
                                        },
                                        "op": "eq"
                                    },
                                    {
                                        "type": "CompCondition",
                                        "left": {
                                            "type": "MsgSenderSelector"
                                        },
                                        "right": {
                                            "type": "StateVarSelector",
                                            "anchor_fn": "getApproved",
                                            "keys": [
                                                {
                                                    "type": "FuncParamSelector",
                                                    "index": 2
                                                }
                                            ]
                                        },
                                        "op": "eq"
                                    },
                                    {
                                        "type": "CompCondition",
                                        "left": {
                                            "type": "MsgSenderSelector"
                                        },
                                        "right": {
                                            "type": "StateVarSelector",
                                            "anchor_fn": "isApprovedForAll",
                                            "keys": [
                                                {
                                                    "type": "FuncParamSelector",
                                                    "index": 0
                                                },
                                                {
                                                    "type": "MsgSenderSelector"
                                                }
                                            ]
                                        },
                                        "op": "eq"
                                    }
                                ]
                            }
                        ]
                    },
                    "type": "EmitVerify"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification, we need to define the conditions under which the `Transfer` event should be emitted according to the rule provided. The rule states that the `Transfer` event should be emitted if:\n1. `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\n2. `_from` is the current owner.\n3. `_to` is not the zero address.\n4. `_tokenId` is a valid NFT.\n\nWe will use the JSON schema provided to construct the verification JSON. We will use the anchor functions `ownerOf`, `getApproved`, and `isApprovedForAll` to verify the ownership and approval conditions. We will also check that `_to` is not the zero address and that `_tokenId` is valid by ensuring it has an owner.\n\nHere is the JSON configuration for the rule verification:\n\n```json\n{\n    \"EmitVerify\": {\n        \"event\": \"Transfer\",\n        \"sv_cond\": {\n            \"type\": \"WrittenCondition\",\n            \"value\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"ownerOf\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 2\n                    }\n                ]\n            }\n        },\n        \"cond\": {\n            \"type\": \"LogicCondition\",\n            \"op\": \"and\",\n            \"conds\": [\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 1\n                    },\n                    \"right\": {\n                        \"type\": \"StateVarSelector\",\n                        \"anchor_fn\": \"ownerOf\",\n                        \"keys\": [\n                            {\n                                \"type\": \"FuncParamSelector\",\n                                \"index\": 2\n                            }\n                        ]\n                    },\n                    \"op\": \"eq\"\n                },\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 1\n                    },\n                    \"right\": {\n                        \"type\": \"ConstantSelector\",\n                        \"value\": \"0x0000000000000000000000000000000000000000\"\n                    },\n                    \"op\": \"not_eq\"\n                },\n                {\n                    \"type\": \"LogicCondition\",\n                    \"op\": \"or\",\n                    \"conds\": [\n                        {\n                            \"type\": \"CompCondition\",\n                            \"left\": {\n                                \"type\": \"MsgSenderSelector\"\n                            },\n                            \"right\": {\n                                \"type\": \"StateVarSelector\",\n                                \"anchor_fn\": \"ownerOf\",\n                                \"keys\": [\n                                    {\n                                        \"type\": \"FuncParamSelector\",\n                                        \"index\": 2\n                                    }\n                                ]\n                            },\n                            \"op\": \"eq\"\n                        },\n                        {\n                            \"type\": \"CompCondition\",\n                            \"left\": {\n                                \"type\": \"MsgSenderSelector\"\n                            },\n                            \"right\": {\n                                \"type\": \"StateVarSelector\",\n                                \"anchor_fn\": \"getApproved\",\n                                \"keys\": [\n                                    {\n                                        \"type\": \"FuncParamSelector\",\n                                        \"index\": 2\n                                    }\n                                ]\n                            },\n                            \"op\": \"eq\"\n                        },\n                        {\n                            \"type\": \"CompCondition\",\n                            \"left\": {\n                                \"type\": \"MsgSenderSelector\"\n                            },\n                            \"right\": {\n                                \"type\": \"StateVarSelector\",\n                                \"anchor_fn\": \"isApprovedForAll\",\n                                \"keys\": [\n                                    {\n                                        \"type\": \"FuncParamSelector\",\n                                        \"index\": 0\n                                    },\n                                    {\n                                        \"type\": \"MsgSenderSelector\"\n                                    }\n                                ]\n                            },\n                            \"op\": \"eq\"\n                        }\n                    ]\n                }\n            ]\n        },\n        \"type\": \"EmitVerify\"\n    }\n}\n```\n\nThis JSON configuration checks all the conditions specified in the rule:\n- It verifies that `_from` is the current owner of `_tokenId`.\n- It checks that `_to` is not the zero address.\n- It ensures that `msg.sender` is either the owner, an approved address, or an authorized operator for `_tokenId`.\n- It uses a `WrittenCondition` to ensure that the `ownerOf` mapping is updated, which implies that `_tokenId` is a valid NFT and that ownership might have changed, triggering the `Transfer` event."
        },
        {
            "rule": "emit '['Approval']' if the owner or an approved operator revokes approval for a token",
            "type": "emit",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable",
            "sym": {
                "EmitVerify": {
                    "event": "Approval",
                    "sv_cond": {
                        "type": "WrittenCondition",
                        "value": {
                            "type": "StateVarSelector",
                            "anchor_fn": "getApproved",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 2
                                }
                            ]
                        }
                    },
                    "type": "EmitVerify"
                }
            }
        },
        {
            "rule": "call onERC721Received if `_to` is a smart contract (code size > 0)",
            "type": "call",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable",
            "sym": {
                "callVerify": {
                    "callee": "onERC721Received",
                    "on": {
                        "index": 1,
                        "type": "FuncParamSelector"
                    },
                    "cond": "is_contract",
                    "type": "CallVerify"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification, we need to specify the conditions under which the `onERC721Received` function should be called. According to the rule, this function should be called when the `_to` address in the `safeTransferFrom` function is a smart contract. This can be determined by checking if the code size at the `_to` address is greater than zero.\n\nHere is the JSON configuration that specifies this rule:\n\n```json\n{\n    \"callVerify\": {\n        \"callee\": \"onERC721Received\",\n        \"on\": {\n            \"index\": 1,\n            \"type\": \"FuncParamSelector\"\n        },\n        \"cond\": \"is_contract\",\n        \"type\": \"CallVerify\"\n    }\n}\n```\n\nExplanation:\n- `\"callee\": \"onERC721Received\"`: This specifies that the function to be verified for being called is `onERC721Received`.\n- `\"on\": { \"index\": 1, \"type\": \"FuncParamSelector\" }`: This indicates that the condition should be checked on the second parameter of the `safeTransferFrom` function, which is `_to` (parameters are zero-indexed, so index 1 corresponds to `_to`).\n- `\"cond\": \"is_contract\"`: This condition specifies that the rule applies only if the address specified by the `on` selector is a smart contract, i.e., its code size is greater than zero.\n- `\"type\": \"CallVerify\"`: This indicates that this JSON object is specifying a call verification rule.\n\nThis configuration ensures that the `onERC721Received` function is called whenever the `_to` parameter in `safeTransferFrom` is a smart contract, adhering to the ERC721 standard for safe transfers."
        },
        {
            "rule": " throw if `msg.sender` is not the current owner, an authorized operator, or the approved address for this NFT",
            "type": "throw",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "LogicCondition",
                        "cond": [
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "MsgSenderSelector"
                                },
                                "right": {
                                    "type": "StateVarSelector",
                                    "anchor_fn": "ownerOf",
                                    "keys": [
                                        {
                                            "type": "FuncParamSelector",
                                            "index": 2
                                        }
                                    ]
                                },
                                "op": "not_eq"
                            },
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "MsgSenderSelector"
                                },
                                "right": {
                                    "type": "StateVarSelector",
                                    "anchor_fn": "getApproved",
                                    "keys": [
                                        {
                                            "type": "FuncParamSelector",
                                            "index": 2
                                        }
                                    ]
                                },
                                "op": "not_eq"
                            },
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "MsgSenderSelector"
                                },
                                "right": {
                                    "type": "StateVarSelector",
                                    "anchor_fn": "isApprovedForAll",
                                    "keys": [
                                        {
                                            "type": "StateVarSelector",
                                            "anchor_fn": "ownerOf",
                                            "keys": [
                                                {
                                                    "type": "FuncParamSelector",
                                                    "index": 2
                                                }
                                            ]
                                        },
                                        {
                                            "type": "MsgSenderSelector"
                                        }
                                    ]
                                },
                                "op": "not_eq"
                            }
                        ],
                        "op": "and"
                    },
                    "op": "not_throw"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification, we need to construct a condition that checks if `msg.sender` is either the current owner, an authorized operator, or the approved address for the NFT. We will use the anchor functions `ownerOf`, `getApproved`, and `isApprovedForAll` to retrieve the necessary state variables.\n\nHere's the JSON configuration for the rule:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"LogicCondition\",\n            \"cond\": [\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"FnCallRetSelector\",\n                        \"fn_name\": \"ownerOf\"\n                    },\n                    \"right\": {\n                        \"type\": \"MsgSenderSelector\"\n                    },\n                    \"op\": \"eq\"\n                },\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"FnCallRetSelector\",\n                        \"fn_name\": \"getApproved\"\n                    },\n                    \"right\": {\n                        \"type\": \"MsgSenderSelector\"\n                    },\n                    \"op\": \"eq\"\n                },\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"FnCallRetSelector\",\n                        \"fn_name\": \"isApprovedForAll\"\n                    },\n                    \"right\": {\n                        \"type\": \"ConstantSelector\",\n                        \"value\": true\n                    },\n                    \"op\": \"eq\"\n                }\n            ],\n            \"op\": \"or\"\n        },\n        \"op\": \"not_throw\"\n    }\n}\n```\n\nExplanation:\n1. **ownerOf Check**: We use a `FnCallRetSelector` to get the return value of the `ownerOf` function, which should be the current owner of the token. We compare this with `msg.sender` using a `CompCondition` with the operation `eq` (equals).\n\n2. **getApproved Check**: Similarly, we use a `FnCallRetSelector` for the `getApproved` function, which returns the address approved for the token. We compare this with `msg.sender`.\n\n3. **isApprovedForAll Check**: We use a `FnCallRetSelector` for the `isApprovedForAll` function, which should return a boolean indicating whether `msg.sender` is an authorized operator for the owner. We compare this boolean value to `true`.\n\n4. **LogicCondition**: We combine the above conditions using a `LogicCondition` with the operation `or`, meaning if any of the conditions are true, the overall condition should be true.\n\n5. **ThrowVerify**: The `ThrowVerify` type is used to specify that the function should not throw if the condition is true. Hence, we use `not_throw` to indicate that the function should proceed without throwing an error if `msg.sender` is the owner, approved, or an authorized operator."
        },
        {
            "rule": " throw if `_from` is not the current owner",
            "type": "throw",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "CompCondition",
                        "left": {
                            "type": "StateVarSelector",
                            "anchor_fn": "ownerOf",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 2
                                }
                            ]
                        },
                        "right": {
                            "type": "FuncParamSelector",
                            "index": 0
                        },
                        "op": "not_eq"
                    },
                    "op": "throw"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification that throws if `_from` is not the current owner in the `safeTransferFrom` function, we need to use the `ownerOf` function as the anchor function. This function checks the owner of a specific token ID, which is essential for verifying if `_from` is indeed the owner of the token.\n\nHere's the JSON configuration for the rule:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"CompCondition\",\n            \"left\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"ownerOf\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 2\n                    }\n                ]\n            },\n            \"right\": {\n                \"type\": \"FuncParamSelector\",\n                \"index\": 0\n            },\n            \"op\": \"not_eq\"\n        },\n        \"op\": \"throw\"\n    }\n}\n```\n\n### Explanation:\n1. **ThrowVerify**: This is the main object that specifies the type of verification (throwing an error under certain conditions).\n2. **cond**: This is the condition under which the throw will occur.\n   - **CompCondition**: This specifies a comparison condition.\n   - **left**: This selects the current owner of the token from the `ownerOf` function, which uses the token ID (`_tokenId`) from the function parameters (`index: 2` of `safeTransferFrom`).\n   - **right**: This selects the `_from` address directly from the function parameters (`index: 0` of `safeTransferFrom`).\n   - **op**: The operation `not_eq` checks if the left side (current owner) is not equal to the right side (`_from` address).\n3. **op**: The operation `throw` specifies that the function should throw an error if the condition is true.\n\nThis configuration ensures that the `safeTransferFrom` function will throw an error if the `_from` address is not the current owner of the token, as determined by the `ownerOf` function."
        },
        {
            "rule": " throw if `_to` is the zero address",
            "type": "throw",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "CompCondition",
                        "left": {
                            "type": "FuncParamSelector",
                            "index": 1
                        },
                        "right": {
                            "type": "ConstantSelector",
                            "value": "0x0000000000000000000000000000000000000000"
                        },
                        "op": "eq"
                    },
                    "op": "throw"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification of the function `safeTransferFrom(address _from, address _to, uint256 _tokenId)`, we need to ensure that the rule \"throw if `_to` is the zero address\" is enforced. This involves using the JSON schema provided to construct a condition that checks if the `_to` parameter is equal to the zero address and throws an error if this condition is true.\n\nHere is the JSON configuration for the rule verification:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"CompCondition\",\n            \"left\": {\n                \"type\": \"FuncParamSelector\",\n                \"index\": 1\n            },\n            \"right\": {\n                \"type\": \"ConstantSelector\",\n                \"value\": \"0x0000000000000000000000000000000000000000\"\n            },\n            \"op\": \"eq\"\n        },\n        \"op\": \"throw\"\n    }\n}\n```\n\nExplanation:\n1. **ThrowVerify**: This is the main object that specifies the type of verification (throwing an error under certain conditions).\n2. **cond**: This is the condition under which the throw will occur.\n   - **type**: \"CompCondition\" specifies that this is a comparison condition.\n   - **left**: This selects the function parameter to compare. Here, `\"index\": 1` refers to the second parameter of the function `safeTransferFrom`, which is `_to`.\n   - **right**: This specifies the constant value to compare against, which in this case is the zero address (`\"0x0000000000000000000000000000000000000000\"`).\n   - **op**: \"eq\" stands for \"equals\", meaning the condition checks if `_to` equals the zero address.\n3. **op**: \"throw\" specifies that the function should throw an error if the condition is true.\n\nThis JSON configuration ensures that the function `safeTransferFrom` will throw an error if the `_to` address is the zero address, adhering to the specified rule."
        },
        {
            "rule": " throw if `_tokenId` is not a valid NFT",
            "type": "throw",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "CompCondition",
                        "left": {
                            "type": "StateVarSelector",
                            "anchor_fn": "ownerOf",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 2
                                }
                            ]
                        },
                        "right": {
                            "type": "ConstantSelector",
                            "value": "0x0000000000000000000000000000000000000000"
                        },
                        "op": "eq"
                    },
                    "op": "throw"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification that throws if `_tokenId` is not a valid NFT, we need to check if the `_tokenId` is associated with an owner in the `ownerOf` function's state variable `_owners`. This mapping holds the relationship between token IDs and their respective owner addresses. If a token ID does not have an associated owner, it is not a valid NFT.\n\nHere's the JSON configuration for this rule:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"CompCondition\",\n            \"left\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"ownerOf\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 2\n                    }\n                ]\n            },\n            \"right\": {\n                \"type\": \"ConstantSelector\",\n                \"value\": \"0x0000000000000000000000000000000000000000\"\n            },\n            \"op\": \"eq\"\n        },\n        \"op\": \"throw\"\n    }\n}\n```\n\n### Explanation:\n1. **ThrowVerify**: This object specifies that the condition should result in a throw if met.\n2. **cond**: The condition that needs to be checked.\n   - **CompCondition**: A comparison condition.\n   - **left**: The left side of the comparison, which selects the owner of the `_tokenId` from the `_owners` mapping.\n     - **StateVarSelector**: Selects a state variable.\n     - **anchor_fn**: Specifies the function that defines the state variable to be checked, which is `ownerOf`.\n     - **keys**: Specifies the keys to access the value in the mapping. Here, it uses the `_tokenId` parameter from the function, which is at index 2 (0-based index).\n   - **right**: The right side of the comparison, which is a constant representing the zero address (`0x0000000000000000000000000000000000000000`). This address is used to check if the token ID is not owned by any valid address.\n   - **op**: The operation to perform in the comparison, which is \"eq\" (equals).\n3. **op**: Specifies the operation to be performed based on the condition. Here, it is \"throw\", meaning the function should throw an error if the condition is true (i.e., if the token ID is associated with the zero address, indicating it is not a valid NFT)."
        },
        {
            "rule": " throw if the return value of `onERC721Received` is not `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`",
            "type": "throw",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable",
            "sym_debug": "To generate the JSON configuration for the rule verification, we need to define a `ThrowVerify` object that checks if the return value of the `onERC721Received` function call is not equal to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`. This involves using a `CompCondition` to compare the return value of the function call with the expected constant value.\n\nHere is the JSON configuration for the rule verification:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"CompCondition\",\n            \"left\": {\n                \"type\": \"FnCallRetSelector\",\n                \"fn_name\": \"onERC721Received\"\n            },\n            \"right\": {\n                \"type\": \"ConstantSelector\",\n                \"value\": \"0x150b7a02\"\n            },\n            \"op\": \"not_eq\"\n        },\n        \"op\": \"throw\"\n    }\n}\n```\n\nExplanation:\n1. **ThrowVerify**: This object specifies that a condition should be checked, and if the condition is true, a throw (revert) should occur.\n2. **cond**: This is the condition that needs to be checked.\n   - **CompCondition**: This specifies a comparison condition.\n   - **left**: This selects the return value of the `onERC721Received` function call.\n   - **right**: This is a constant selector that specifies the expected return value, which is the `bytes4` hash of the string `\"onERC721Received(address,address,uint256,bytes)\"`. The hash value `0x150b7a02` is precomputed for simplicity.\n   - **op**: The operation `not_eq` means the condition checks if the left value is not equal to the right value.\n3. **op**: The operation `throw` specifies that the contract should throw if the condition is true.\n\nThis configuration ensures that the smart contract will revert if the `onERC721Received` function does not return the expected identifier, enforcing compliance with the ERC721 standard for safe transfers.",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "CompCondition",
                        "left": {
                            "type": "FnCallRetSelector",
                            "fn_name": "onERC721Received"
                        },
                        "right": {
                            "type": "ConstantSelector",
                            "value": "0x150b7a02"
                        },
                        "op": "not_eq"
                    },
                    "op": "throw"
                }
            }
        },
        {
            "rule": "emit '['Transfer']' if `_from` is the current owner, an authorized operator, or the approved address for this NFT, `_to` is not the zero address, `_tokenId` is a valid NFT",
            "type": "emit",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable",
            "sym": {
                "EmitVerify": {
                    "event": "Transfer",
                    "sv_cond": {
                        "type": "WrittenCondition",
                        "value": {
                            "type": "StateVarSelector",
                            "anchor_fn": "ownerOf",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 2
                                }
                            ]
                        }
                    },
                    "cond": {
                        "type": "LogicCondition",
                        "op": "and",
                        "conds": [
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "FuncParamSelector",
                                    "index": 1
                                },
                                "right": {
                                    "type": "ConstantSelector",
                                    "value": "0x0000000000000000000000000000000000000000"
                                },
                                "op": "not_eq"
                            },
                            {
                                "type": "LogicCondition",
                                "op": "or",
                                "conds": [
                                    {
                                        "type": "CompCondition",
                                        "left": {
                                            "type": "FuncParamSelector",
                                            "index": 0
                                        },
                                        "right": {
                                            "type": "StateVarSelector",
                                            "anchor_fn": "ownerOf",
                                            "keys": [
                                                {
                                                    "type": "FuncParamSelector",
                                                    "index": 2
                                                }
                                            ]
                                        },
                                        "op": "eq"
                                    },
                                    {
                                        "type": "CompCondition",
                                        "left": {
                                            "type": "FuncParamSelector",
                                            "index": 0
                                        },
                                        "right": {
                                            "type": "StateVarSelector",
                                            "anchor_fn": "getApproved",
                                            "keys": [
                                                {
                                                    "type": "FuncParamSelector",
                                                    "index": 2
                                                }
                                            ]
                                        },
                                        "op": "eq"
                                    },
                                    {
                                        "type": "CompCondition",
                                        "left": {
                                            "type": "FuncParamSelector",
                                            "index": 0
                                        },
                                        "right": {
                                            "type": "StateVarSelector",
                                            "anchor_fn": "isApprovedForAll",
                                            "keys": [
                                                {
                                                    "type": "FuncParamSelector",
                                                    "index": 0
                                                },
                                                {
                                                    "type": "FuncParamSelector",
                                                    "index": 1
                                                }
                                            ]
                                        },
                                        "op": "eq"
                                    }
                                ]
                            }
                        ]
                    },
                    "type": "EmitVerify"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification of the `safeTransferFrom` function, we need to ensure that the conditions specified in the rule are met before the `Transfer` event is emitted. The conditions are:\n\n1. `_from` is the current owner, an authorized operator, or the approved address for this NFT.\n2. `_to` is not the zero address.\n3. `_tokenId` is a valid NFT.\n\nWe will use the JSON schema provided to construct the verification JSON. Here's how the JSON configuration might look:\n\n```json\n{\n    \"EmitVerify\": {\n        \"event\": \"Transfer\",\n        \"sv_cond\": {\n            \"type\": \"WrittenCondition\",\n            \"value\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"ownerOf\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 2\n                    }\n                ]\n            }\n        },\n        \"cond\": {\n            \"type\": \"LogicCondition\",\n            \"op\": \"and\",\n            \"conds\": [\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 1\n                    },\n                    \"right\": {\n                        \"type\": \"ConstantSelector\",\n                        \"value\": \"0x0000000000000000000000000000000000000000\"\n                    },\n                    \"op\": \"not_eq\"\n                },\n                {\n                    \"type\": \"LogicCondition\",\n                    \"op\": \"or\",\n                    \"conds\": [\n                        {\n                            \"type\": \"CompCondition\",\n                            \"left\": {\n                                \"type\": \"FuncParamSelector\",\n                                \"index\": 0\n                            },\n                            \"right\": {\n                                \"type\": \"StateVarSelector\",\n                                \"anchor_fn\": \"ownerOf\",\n                                \"keys\": [\n                                    {\n                                        \"type\": \"FuncParamSelector\",\n                                        \"index\": 2\n                                    }\n                                ]\n                            },\n                            \"op\": \"eq\"\n                        },\n                        {\n                            \"type\": \"CompCondition\",\n                            \"left\": {\n                                \"type\": \"FuncParamSelector\",\n                                \"index\": 0\n                            },\n                            \"right\": {\n                                \"type\": \"StateVarSelector\",\n                                \"anchor_fn\": \"getApproved\",\n                                \"keys\": [\n                                    {\n                                        \"type\": \"FuncParamSelector\",\n                                        \"index\": 2\n                                    }\n                                ]\n                            },\n                            \"op\": \"eq\"\n                        },\n                        {\n                            \"type\": \"CompCondition\",\n                            \"left\": {\n                                \"type\": \"FuncParamSelector\",\n                                \"index\": 0\n                            },\n                            \"right\": {\n                                \"type\": \"StateVarSelector\",\n                                \"anchor_fn\": \"isApprovedForAll\",\n                                \"keys\": [\n                                    {\n                                        \"type\": \"FuncParamSelector\",\n                                        \"index\": 0\n                                    },\n                                    {\n                                        \"type\": \"FuncParamSelector\",\n                                        \"index\": 1\n                                    }\n                                ]\n                            },\n                            \"op\": \"eq\"\n                        }\n                    ]\n                }\n            ]\n        },\n        \"type\": \"EmitVerify\"\n    }\n}\n```\n\nExplanation:\n- The `sv_cond` checks that the `ownerOf` function's return value (owner of the token) is written to the state variable `_owners` for the given `_tokenId`.\n- The `cond` checks that:\n  - `_to` is not the zero address.\n  - `_from` is either the current owner, an authorized operator, or the approved address for `_tokenId`. This is done using a logical OR condition combining checks against the `ownerOf`, `getApproved`, and `isApprovedForAll` functions.\n  \nThis configuration ensures that the `Transfer` event is emitted only if all specified conditions are met, aligning with the rule provided."
        },
        {
            "rule": "emit '['Approval']' if the approved address for this NFT is reset (commonly to address(0))",
            "type": "emit",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable",
            "sym": {
                "EmitVerify": {
                    "event": "Approval",
                    "sv_cond": {
                        "type": "WrittenCondition",
                        "value": {
                            "type": "StateVarSelector",
                            "anchor_fn": "getApproved",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 2
                                }
                            ]
                        },
                        "change_type": "change"
                    },
                    "cond": {
                        "type": "CompCondition",
                        "left": {
                            "type": "StateVarSelector",
                            "anchor_fn": "getApproved",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 2
                                }
                            ]
                        },
                        "right": {
                            "type": "ConstantSelector",
                            "value": "0x0000000000000000000000000000000000000000"
                        },
                        "op": "eq"
                    },
                    "type": "EmitVerify"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification, we need to focus on the `safeTransferFrom` function and the condition that the \"Approval\" event should be emitted if the approved address for an NFT is reset to `address(0)`. This involves checking the state variable `_tokenApprovals` which maps a token ID to its approved address.\n\nHere's the JSON configuration based on the provided schema:\n\n```json\n{\n    \"EmitVerify\": {\n        \"event\": \"Approval\",\n        \"sv_cond\": {\n            \"type\": \"WrittenCondition\",\n            \"value\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"getApproved\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 2\n                    }\n                ]\n            },\n            \"change_type\": \"change\"\n        },\n        \"cond\": {\n            \"type\": \"CompCondition\",\n            \"left\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"getApproved\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 2\n                    }\n                ]\n            },\n            \"right\": {\n                \"type\": \"ConstantSelector\",\n                \"value\": \"0x0000000000000000000000000000000000000000\"\n            },\n            \"op\": \"eq\"\n        },\n        \"type\": \"EmitVerify\"\n    }\n}\n```\n\n### Explanation:\n1. **Event**: We specify that the event to verify is \"Approval\".\n2. **sv_cond**: This condition checks if the state variable `_tokenApprovals` is written to during the function call.\n   - **anchor_fn**: `getApproved` is used as the anchor function since it directly relates to the `_tokenApprovals` mapping.\n   - **keys**: We use a `FuncParamSelector` to select the `_tokenId` parameter (index 2) from the `safeTransferFrom` function.\n3. **cond**: This condition checks if the new value of `_tokenApprovals` for the given `_tokenId` is equal to `address(0)`.\n   - **left**: Again, selects the value from `_tokenApprovals` for the given `_tokenId`.\n   - **right**: A `ConstantSelector` specifying the constant value `address(0)` (represented as a zero address).\n   - **op**: The operation is \"eq\" (equals), ensuring the condition checks for equality.\n\nThis configuration ensures that the \"Approval\" event is verified to be emitted if and only if the approved address for the specified NFT (`_tokenId`) is reset to `address(0)` during the execution of `safeTransferFrom`."
        },
        {
            "rule": "emit '['ERC721Received']' if `_to` is a smart contract and `onERC721Received` is successfully called on `_to`",
            "type": "emit",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable",
            "sym": {
                "EmitVerify": {
                    "type": "EmitVerify",
                    "event": "ERC721Received",
                    "sv_cond": {
                        "type": "WrittenCondition",
                        "value": {
                            "type": "StateVarSelector",
                            "anchor_fn": "ownerOf",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 2
                                }
                            ]
                        }
                    },
                    "cond": {
                        "type": "LogicCondition",
                        "op": "and",
                        "conds": [
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "FuncParamSelector",
                                    "index": 1
                                },
                                "right": {
                                    "type": "ConstantSelector",
                                    "value": "address(0)"
                                },
                                "op": "not_eq"
                            },
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "FuncParamSelector",
                                    "index": 1
                                },
                                "right": {
                                    "type": "ConstantSelector",
                                    "value": "true"
                                },
                                "op": "eq"
                            }
                        ]
                    },
                    "within_call_fn": "onERC721Received"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification based on the provided schema and the rule description, we need to focus on the conditions under which the `ERC721Received` event should be emitted. The rule states that this event should be emitted if `_to` is a smart contract and `onERC721Received` is successfully called on `_to`.\n\nHere's the JSON configuration for this rule:\n\n```json\n{\n    \"EmitVerify\": {\n        \"type\": \"EmitVerify\",\n        \"event\": \"ERC721Received\",\n        \"sv_cond\": {\n            \"type\": \"WrittenCondition\",\n            \"value\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"ownerOf\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 2\n                    }\n                ]\n            }\n        },\n        \"cond\": {\n            \"type\": \"LogicCondition\",\n            \"op\": \"and\",\n            \"conds\": [\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 1\n                    },\n                    \"right\": {\n                        \"type\": \"ConstantSelector\",\n                        \"value\": \"address(0)\"\n                    },\n                    \"op\": \"not_eq\"\n                },\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 1\n                    },\n                    \"right\": {\n                        \"type\": \"ConstantSelector\",\n                        \"value\": \"true\"\n                    },\n                    \"op\": \"eq\"\n                }\n            ]\n        },\n        \"within_call_fn\": \"onERC721Received\"\n    }\n}\n```\n\n### Explanation:\n1. **EmitVerify**: This is the main object that specifies the verification of the `ERC721Received` event emission.\n2. **event**: Specifies the event name `ERC721Received` that should be emitted.\n3. **sv_cond**: Specifies a condition related to state variable changes. Here, it checks if the owner of the token (from the `ownerOf` function) has changed.\n   - **StateVarSelector**: Points to the state variable `_owners` which is modified in the `ownerOf` function.\n   - **FuncParamSelector**: Points to the `_tokenId` parameter (index 2) of the `safeTransferFrom` function.\n4. **cond**: Specifies logical conditions that must be met for the event to be emitted.\n   - The first condition checks if `_to` is not a zero address (indicating it's a valid address).\n   - The second condition checks if the `onERC721Received` call returned `true`, indicating successful execution.\n5. **within_call_fn**: Specifies that the event should be emitted within the context of the `onERC721Received` function call.\n\nThis configuration ensures that the `ERC721Received` event is emitted under the specified conditions, aligning with the rule described."
        },
        {
            "rule": "call onERC721Received if `_to` is a smart contract (code size > 0)",
            "type": "call",
            "interface": "function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable",
            "sym": {
                "callVerify": {
                    "callee": "onERC721Received",
                    "on": {
                        "index": 1,
                        "type": "FuncParamSelector"
                    },
                    "cond": "is_contract",
                    "type": "CallVerify"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification of the `safeTransferFrom` function, we need to ensure that the function calls `onERC721Received` on the `_to` address if it is a smart contract. This involves checking the code size of the `_to` address to determine if it is a contract and then verifying that the `onERC721Received` function is called.\n\nHere is the JSON configuration based on the provided schema:\n\n```json\n{\n    \"callVerify\": {\n        \"callee\": \"onERC721Received\",\n        \"on\": {\n            \"index\": 1,\n            \"type\": \"FuncParamSelector\"\n        },\n        \"cond\": \"is_contract\",\n        \"type\": \"CallVerify\",\n        \"arg_verifiers\": [\n            {\n                \"arg_index\": 0,\n                \"expected_value\": {\n                    \"value\": {\n                        \"type\": \"MsgSenderSelector\"\n                    },\n                    \"cond\": {\n                        \"type\": \"CompCondition\",\n                        \"operator\": \"==\",\n                        \"rhs\": {\n                            \"type\": \"FuncParamSelector\",\n                            \"index\": 0\n                        }\n                    }\n                },\n                \"type\": \"ArgVerify\"\n            },\n            {\n                \"arg_index\": 1,\n                \"expected_value\": {\n                    \"value\": {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 2\n                    },\n                    \"cond\": {\n                        \"type\": \"CompCondition\",\n                        \"operator\": \"==\",\n                        \"rhs\": {\n                            \"type\": \"ConstantSelector\",\n                            \"value\": \"tokenId\"\n                        }\n                    }\n                },\n                \"type\": \"ArgVerify\"\n            },\n            {\n                \"arg_index\": 2,\n                \"expected_value\": {\n                    \"value\": {\n                        \"type\": \"ConstantSelector\",\n                        \"value\": \"bytes4(keccak256('onERC721Received(address,address,uint256,bytes)'))\"\n                    },\n                    \"cond\": {\n                        \"type\": \"CompCondition\",\n                        \"operator\": \"==\",\n                        \"rhs\": {\n                            \"type\": \"ConstantSelector\",\n                            \"value\": \"bytes4(keccak256('onERC721Received(address,address,uint256,bytes)'))\"\n                        }\n                    }\n                },\n                \"type\": \"ArgVerify\"\n            }\n        ]\n    }\n}\n```\n\nExplanation:\n- The `callVerify` object specifies that we are verifying a function call to `onERC721Received`.\n- The `callee` field specifies the name of the function being called.\n- The `on` field uses a `FuncParamSelector` to select the second parameter (`_to`) of the `safeTransferFrom` function to check if it is a contract.\n- The `cond` field specifies the condition `is_contract`, which checks if the address is a contract.\n- The `arg_verifiers` array contains verifiers for the arguments passed to `onERC721Received`:\n  - The first argument should be the address of the contract making the call (`msg.sender`).\n  - The second argument should be the `_tokenId` passed to `safeTransferFrom`.\n  - The third argument should be the selector for the `onERC721Received` function.\n\nThis configuration ensures that the `safeTransferFrom` function adheres to the ERC721 standard by calling `onERC721Received` on the `_to` address when it is a contract."
        },
        {
            "rule": " throw if `msg.sender` is not the current owner, an authorized operator, or the approved address for this NFT",
            "type": "throw",
            "interface": "function transferFrom(address _from, address _to, uint256 _tokenId) external payable",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "LogicCondition",
                        "cond": [
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "MsgSenderSelector"
                                },
                                "right": {
                                    "type": "StateVarSelector",
                                    "anchor_fn": "ownerOf",
                                    "keys": [
                                        {
                                            "type": "FuncParamSelector",
                                            "index": 2
                                        }
                                    ]
                                },
                                "op": "not_eq"
                            },
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "MsgSenderSelector"
                                },
                                "right": {
                                    "type": "StateVarSelector",
                                    "anchor_fn": "getApproved",
                                    "keys": [
                                        {
                                            "type": "FuncParamSelector",
                                            "index": 2
                                        }
                                    ]
                                },
                                "op": "not_eq"
                            },
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "MsgSenderSelector"
                                },
                                "right": {
                                    "type": "StateVarSelector",
                                    "anchor_fn": "isApprovedForAll",
                                    "keys": [
                                        {
                                            "type": "StateVarSelector",
                                            "anchor_fn": "ownerOf",
                                            "keys": [
                                                {
                                                    "type": "FuncParamSelector",
                                                    "index": 2
                                                }
                                            ]
                                        },
                                        {
                                            "type": "MsgSenderSelector"
                                        }
                                    ]
                                },
                                "op": "not_eq"
                            }
                        ],
                        "op": "and"
                    },
                    "op": "throw"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification of the `transferFrom` function, we need to ensure that the `msg.sender` is either the current owner, an authorized operator, or the approved address for the NFT. We will use the provided JSON schema and the anchor functions to construct the necessary conditions.\n\nHere's the JSON configuration for the rule:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"LogicCondition\",\n            \"cond\": [\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"MsgSenderSelector\"\n                    },\n                    \"right\": {\n                        \"type\": \"StateVarSelector\",\n                        \"anchor_fn\": \"ownerOf\",\n                        \"keys\": [\n                            {\n                                \"type\": \"FuncParamSelector\",\n                                \"index\": 2\n                            }\n                        ]\n                    },\n                    \"op\": \"not_eq\"\n                },\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"MsgSenderSelector\"\n                    },\n                    \"right\": {\n                        \"type\": \"StateVarSelector\",\n                        \"anchor_fn\": \"getApproved\",\n                        \"keys\": [\n                            {\n                                \"type\": \"FuncParamSelector\",\n                                \"index\": 2\n                            }\n                        ]\n                    },\n                    \"op\": \"not_eq\"\n                },\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"MsgSenderSelector\"\n                    },\n                    \"right\": {\n                        \"type\": \"StateVarSelector\",\n                        \"anchor_fn\": \"isApprovedForAll\",\n                        \"keys\": [\n                            {\n                                \"type\": \"StateVarSelector\",\n                                \"anchor_fn\": \"ownerOf\",\n                                \"keys\": [\n                                    {\n                                        \"type\": \"FuncParamSelector\",\n                                        \"index\": 2\n                                    }\n                                ]\n                            },\n                            {\n                                \"type\": \"MsgSenderSelector\"\n                            }\n                        ]\n                    },\n                    \"op\": \"not_eq\"\n                }\n            ],\n            \"op\": \"and\"\n        },\n        \"op\": \"throw\"\n    }\n}\n```\n\nExplanation:\n1. **Owner Check**: We use the `ownerOf` function to check if the `msg.sender` is the owner of the token. The token ID is passed as the third function parameter (`_tokenId`), hence `index: 2`.\n2. **Approved Address Check**: We use the `getApproved` function to check if the `msg.sender` is the approved address for the token.\n3. **Operator Approval Check**: We use the `isApprovedForAll` function to check if the `msg.sender` is an authorized operator for the owner of the token. This involves checking the mapping from the owner (obtained via `ownerOf`) to the operator (`msg.sender`).\n4. **Logical Condition**: We combine these conditions using an \"and\" logical operator, meaning all conditions must evaluate to `not_eq` (i.e., false) for the rule to throw, indicating that the `msg.sender` is neither the owner, nor an approved address, nor an authorized operator.\n\nThis configuration ensures that the function will throw if the `msg.sender` does not meet any of the required conditions to execute `transferFrom`."
        },
        {
            "rule": " throw if `_from` is not the current owner",
            "type": "throw",
            "interface": "function transferFrom(address _from, address _to, uint256 _tokenId) external payable",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "CompCondition",
                        "left": {
                            "type": "StateVarSelector",
                            "anchor_fn": "ownerOf",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 2
                                }
                            ]
                        },
                        "right": {
                            "type": "FuncParamSelector",
                            "index": 0
                        },
                        "op": "not_eq"
                    },
                    "op": "throw"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification that throws if `_from` is not the current owner in the `transferFrom` function, we need to use the `ownerOf` function as the anchor function. This function checks the owner of a specific token ID, which is exactly what we need to verify.\n\nHere's the JSON configuration for the rule:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"CompCondition\",\n            \"left\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"ownerOf\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 2\n                    }\n                ]\n            },\n            \"right\": {\n                \"type\": \"FuncParamSelector\",\n                \"index\": 0\n            },\n            \"op\": \"not_eq\"\n        },\n        \"op\": \"throw\"\n    }\n}\n```\n\nExplanation:\n- **ThrowVerify**: This object specifies that a condition should be checked and if it evaluates to true, a throw should occur.\n- **cond**: This is the condition that needs to be evaluated.\n  - **CompCondition**: This specifies a comparison condition.\n  - **left**: This selects the current owner of the token using the `ownerOf` function. The `keys` array specifies that the token ID to check is the third parameter (`_tokenId`) of the `transferFrom` function (index 2, since indexing starts at 0).\n  - **right**: This selects the `_from` address, which is the first parameter of the `transferFrom` function (index 0).\n  - **op**: The operation `not_eq` checks if the left side (current owner) is not equal to the right side (`_from` address).\n- **op**: The operation `throw` specifies that the function should throw an error if the condition is true, meaning if `_from` is not the current owner of `_tokenId`.\n\nThis configuration ensures that the `transferFrom` function will throw an error if the `_from` address is not the current owner of the token specified by `_tokenId`, adhering to the specified rule."
        },
        {
            "rule": " throw if `_to` is the zero address",
            "type": "throw",
            "interface": "function transferFrom(address _from, address _to, uint256 _tokenId) external payable",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "CompCondition",
                        "left": {
                            "type": "FuncParamSelector",
                            "index": 1
                        },
                        "right": {
                            "type": "ConstantSelector",
                            "value": "0x0000000000000000000000000000000000000000"
                        },
                        "op": "eq"
                    },
                    "op": "throw"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification that throws if `_to` is the zero address in the function `transferFrom(address _from, address _to, uint256 _tokenId)`, we need to define a condition that checks if the `_to` parameter is equal to the zero address. If this condition is true, the function should throw an error.\n\nHere's the JSON configuration for this rule:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"CompCondition\",\n            \"left\": {\n                \"type\": \"FuncParamSelector\",\n                \"index\": 1\n            },\n            \"right\": {\n                \"type\": \"ConstantSelector\",\n                \"value\": \"0x0000000000000000000000000000000000000000\"\n            },\n            \"op\": \"eq\"\n        },\n        \"op\": \"throw\"\n    }\n}\n```\n\nExplanation:\n1. **ThrowVerify**: This is the main object that specifies the type of verification (throwing an error under certain conditions).\n2. **cond**: This is the condition under which the throw should occur.\n   - **type**: \"CompCondition\" specifies that this is a comparison condition.\n   - **left**: This selects the function parameter to compare. Here, `\"index\": 1` refers to the second parameter of the function, which is `_to`.\n   - **right**: This specifies the constant value to compare against, which is the zero address (`\"0x0000000000000000000000000000000000000000\"`).\n   - **op**: \"eq\" specifies that the operation is an equality check.\n3. **op**: \"throw\" specifies that the function should throw an error if the condition is true.\n\nThis JSON configuration ensures that the `transferFrom` function will throw an error if the `_to` address is the zero address, adhering to the specified rule."
        },
        {
            "rule": " throw if `_tokenId` is not a valid NFT",
            "type": "throw",
            "interface": "function transferFrom(address _from, address _to, uint256 _tokenId) external payable",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "CompCondition",
                        "left": {
                            "type": "StateVarSelector",
                            "anchor_fn": "ownerOf",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 2
                                }
                            ]
                        },
                        "right": {
                            "type": "ConstantSelector",
                            "value": "0x0000000000000000000000000000000000000000"
                        },
                        "op": "eq"
                    },
                    "op": "throw"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification that throws if `_tokenId` is not a valid NFT, we need to check if the `_tokenId` has an associated owner in the `_owners` mapping. This can be done by verifying that the owner address is not the zero address (indicating that the token is owned by someone). Here's how you can structure the JSON configuration for this rule:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"CompCondition\",\n            \"left\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"ownerOf\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 2\n                    }\n                ]\n            },\n            \"right\": {\n                \"type\": \"ConstantSelector\",\n                \"value\": \"0x0000000000000000000000000000000000000000\"\n            },\n            \"op\": \"eq\"\n        },\n        \"op\": \"throw\"\n    }\n}\n```\n\n### Explanation:\n1. **ThrowVerify**: This is the main object that specifies the condition under which the function should throw an error.\n2. **cond**: This is the condition that needs to be met for the function to throw. It is a comparison condition.\n3. **CompCondition**: Specifies that we are comparing two values.\n4. **left**: This selects the left operand of the comparison, which is the owner address of the `_tokenId` from the `_owners` mapping.\n   - **StateVarSelector**: This selects a state variable.\n   - **anchor_fn**: `ownerOf` is used as the anchor function to access the `_owners` mapping.\n   - **keys**: Specifies the keys used to access the mapping. Here, it uses the `_tokenId` parameter of the function, which is at index 2 (0-based index).\n5. **right**: This is the right operand of the comparison, which is the zero address. If the owner address is the zero address, it means the token ID is not valid (not owned by anyone).\n   - **ConstantSelector**: Specifies a constant value.\n   - **value**: The zero address, represented as a string.\n6. **op**: The comparison operator used. Here, `eq` means \"equals\".\n7. **op** (in ThrowVerify): Specifies the operation to perform based on the condition. `throw` means the function should throw an error if the condition is true.\n\nThis JSON configuration ensures that the `transferFrom` function will throw an error if the `_tokenId` does not correspond to a valid NFT, i.e., if there is no owner (owner address is the zero address)."
        },
        {
            "rule": "emit '['Transfer']' if msg.sender is the current owner, an authorized operator, or the approved address for this NFT, `_from` is the current owner, `_to` is not the zero address, and `_tokenId` is a valid NFT",
            "type": "emit",
            "interface": "function transferFrom(address _from, address _to, uint256 _tokenId) external payable",
            "sym": {
                "EmitVerify": {
                    "event": "Transfer",
                    "sv_cond": {
                        "type": "WrittenCondition",
                        "value": {
                            "type": "StateVarSelector",
                            "anchor_fn": "ownerOf",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 2
                                }
                            ]
                        }
                    },
                    "cond": {
                        "type": "LogicCondition",
                        "op": "and",
                        "conds": [
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "FuncParamSelector",
                                    "index": 1
                                },
                                "right": {
                                    "type": "StateVarSelector",
                                    "anchor_fn": "ownerOf",
                                    "keys": [
                                        {
                                            "type": "FuncParamSelector",
                                            "index": 2
                                        }
                                    ]
                                },
                                "op": "eq"
                            },
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "FuncParamSelector",
                                    "index": 1
                                },
                                "right": {
                                    "type": "ConstantSelector",
                                    "value": "0x0000000000000000000000000000000000000000"
                                },
                                "op": "not_eq"
                            },
                            {
                                "type": "LogicCondition",
                                "op": "or",
                                "conds": [
                                    {
                                        "type": "CompCondition",
                                        "left": {
                                            "type": "MsgSenderSelector"
                                        },
                                        "right": {
                                            "type": "StateVarSelector",
                                            "anchor_fn": "ownerOf",
                                            "keys": [
                                                {
                                                    "type": "FuncParamSelector",
                                                    "index": 2
                                                }
                                            ]
                                        },
                                        "op": "eq"
                                    },
                                    {
                                        "type": "CompCondition",
                                        "left": {
                                            "type": "MsgSenderSelector"
                                        },
                                        "right": {
                                            "type": "StateVarSelector",
                                            "anchor_fn": "getApproved",
                                            "keys": [
                                                {
                                                    "type": "FuncParamSelector",
                                                    "index": 2
                                                }
                                            ]
                                        },
                                        "op": "eq"
                                    },
                                    {
                                        "type": "CompCondition",
                                        "left": {
                                            "type": "MsgSenderSelector"
                                        },
                                        "right": {
                                            "type": "StateVarSelector",
                                            "anchor_fn": "isApprovedForAll",
                                            "keys": [
                                                {
                                                    "type": "FuncParamSelector",
                                                    "index": 0
                                                },
                                                {
                                                    "type": "MsgSenderSelector"
                                                }
                                            ]
                                        },
                                        "op": "eq"
                                    }
                                ]
                            }
                        ]
                    },
                    "type": "EmitVerify"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification of the `transferFrom` function, we need to ensure that the conditions specified in the rule are met before the `Transfer` event is emitted. The conditions are:\n\n1. `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\n2. `_from` is the current owner.\n3. `_to` is not the zero address.\n4. `_tokenId` is a valid NFT.\n\nGiven the JSON schema and the anchor functions provided, we can construct the JSON configuration as follows:\n\n```json\n{\n    \"EmitVerify\": {\n        \"event\": \"Transfer\",\n        \"sv_cond\": {\n            \"type\": \"WrittenCondition\",\n            \"value\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"ownerOf\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 2\n                    }\n                ]\n            }\n        },\n        \"cond\": {\n            \"type\": \"LogicCondition\",\n            \"op\": \"and\",\n            \"conds\": [\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 1\n                    },\n                    \"right\": {\n                        \"type\": \"StateVarSelector\",\n                        \"anchor_fn\": \"ownerOf\",\n                        \"keys\": [\n                            {\n                                \"type\": \"FuncParamSelector\",\n                                \"index\": 2\n                            }\n                        ]\n                    },\n                    \"op\": \"eq\"\n                },\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 1\n                    },\n                    \"right\": {\n                        \"type\": \"ConstantSelector\",\n                        \"value\": \"0x0000000000000000000000000000000000000000\"\n                    },\n                    \"op\": \"not_eq\"\n                },\n                {\n                    \"type\": \"LogicCondition\",\n                    \"op\": \"or\",\n                    \"conds\": [\n                        {\n                            \"type\": \"CompCondition\",\n                            \"left\": {\n                                \"type\": \"MsgSenderSelector\"\n                            },\n                            \"right\": {\n                                \"type\": \"StateVarSelector\",\n                                \"anchor_fn\": \"ownerOf\",\n                                \"keys\": [\n                                    {\n                                        \"type\": \"FuncParamSelector\",\n                                        \"index\": 2\n                                    }\n                                ]\n                            },\n                            \"op\": \"eq\"\n                        },\n                        {\n                            \"type\": \"CompCondition\",\n                            \"left\": {\n                                \"type\": \"MsgSenderSelector\"\n                            },\n                            \"right\": {\n                                \"type\": \"StateVarSelector\",\n                                \"anchor_fn\": \"getApproved\",\n                                \"keys\": [\n                                    {\n                                        \"type\": \"FuncParamSelector\",\n                                        \"index\": 2\n                                    }\n                                ]\n                            },\n                            \"op\": \"eq\"\n                        },\n                        {\n                            \"type\": \"CompCondition\",\n                            \"left\": {\n                                \"type\": \"MsgSenderSelector\"\n                            },\n                            \"right\": {\n                                \"type\": \"StateVarSelector\",\n                                \"anchor_fn\": \"isApprovedForAll\",\n                                \"keys\": [\n                                    {\n                                        \"type\": \"FuncParamSelector\",\n                                        \"index\": 0\n                                    },\n                                    {\n                                        \"type\": \"MsgSenderSelector\"\n                                    }\n                                ]\n                            },\n                            \"op\": \"eq\"\n                        }\n                    ]\n                }\n            ]\n        },\n        \"type\": \"EmitVerify\"\n    }\n}\n```\n\nThis JSON configuration checks that:\n- The `Transfer` event should be emitted.\n- The `_tokenId` is associated with an owner (`ownerOf` mapping).\n- The `_from` address matches the owner of `_tokenId`.\n- The `_to` address is not the zero address.\n- The `msg.sender` is either the owner, an approved address, or an authorized operator for the `_tokenId`. \n\nThis configuration uses the `LogicCondition` and `CompCondition` to ensure all conditions are met before the `Transfer` event is emitted."
        },
        {
            "rule": " throw if `msg.sender` is not the current NFT owner and not an authorized operator of the current owner",
            "type": "throw",
            "interface": "function approve(address _approved, uint256 _tokenId) external payable",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "LogicCondition",
                        "cond": [
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "MsgSenderSelector"
                                },
                                "right": {
                                    "type": "StateVarSelector",
                                    "anchor_fn": "ownerOf",
                                    "keys": [
                                        {
                                            "type": "FuncParamSelector",
                                            "index": 1
                                        }
                                    ]
                                },
                                "op": "not_eq"
                            },
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "FnCallRetSelector",
                                    "fn_name": "isApprovedForAll",
                                    "keys": [
                                        {
                                            "type": "StateVarSelector",
                                            "anchor_fn": "ownerOf",
                                            "keys": [
                                                {
                                                    "type": "FuncParamSelector",
                                                    "index": 1
                                                }
                                            ]
                                        },
                                        {
                                            "type": "MsgSenderSelector"
                                        }
                                    ]
                                },
                                "right": {
                                    "type": "ConstantSelector",
                                    "value": false
                                },
                                "op": "eq"
                            }
                        ],
                        "op": "and"
                    },
                    "op": "throw"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification, we need to construct a condition that checks if `msg.sender` is not the current NFT owner and is not an authorized operator of the current owner. This condition should result in a \"throw\" if true.\n\nGiven the anchor functions and their associated state variables, we can use:\n- `ownerOf(uint256 _tokenId)` to get the current owner of the NFT.\n- `isApprovedForAll(address _owner, address _operator)` to check if an operator is authorized by the owner.\n\nHere's the JSON configuration for the rule verification:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"LogicCondition\",\n            \"cond\": [\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"MsgSenderSelector\"\n                    },\n                    \"right\": {\n                        \"type\": \"StateVarSelector\",\n                        \"anchor_fn\": \"ownerOf\",\n                        \"keys\": [\n                            {\n                                \"type\": \"FuncParamSelector\",\n                                \"index\": 1\n                            }\n                        ]\n                    },\n                    \"op\": \"not_eq\"\n                },\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"FnCallRetSelector\",\n                        \"fn_name\": \"isApprovedForAll\",\n                        \"keys\": [\n                            {\n                                \"type\": \"StateVarSelector\",\n                                \"anchor_fn\": \"ownerOf\",\n                                \"keys\": [\n                                    {\n                                        \"type\": \"FuncParamSelector\",\n                                        \"index\": 1\n                                    }\n                                ]\n                            },\n                            {\n                                \"type\": \"MsgSenderSelector\"\n                            }\n                        ]\n                    },\n                    \"right\": {\n                        \"type\": \"ConstantSelector\",\n                        \"value\": false\n                    },\n                    \"op\": \"eq\"\n                }\n            ],\n            \"op\": \"and\"\n        },\n        \"op\": \"throw\"\n    }\n}\n```\n\nExplanation:\n1. The `LogicCondition` uses the logical operator `and` to combine two conditions:\n   - The first `CompCondition` checks if `msg.sender` is not equal to the owner of the token (retrieved using `ownerOf`).\n   - The second `CompCondition` checks if `msg.sender` is not an approved operator for the owner (using `isApprovedForAll`).\n\n2. If both conditions are true (i.e., `msg.sender` is neither the owner nor an authorized operator), the rule specifies to \"throw\", indicating that the transaction should be reverted.\n\nThis configuration ensures that the function `approve` adheres to the specified rule, throwing an error if an unauthorized user attempts to approve a transfer."
        },
        {
            "rule": "emit '['ApprovalForAll']' if always",
            "type": "emit",
            "interface": "function setApprovalForAll(address _operator, bool _approved) external",
            "sym": {
                "EmitVerify": {
                    "event": "ApprovalForAll",
                    "type": "EmitVerify"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification of the function `setApprovalForAll(address _operator, bool _approved) external` which requires the emission of the `ApprovalForAll` event, we need to consider the following:\n\n1. The function `setApprovalForAll` modifies the state variable `_operatorApprovals` which maps from owner to operator approvals.\n2. The rule specifies that the `ApprovalForAll` event should always be emitted when this function is called.\n\nGiven this, the JSON configuration should specify that the `ApprovalForAll` event must be emitted and it should verify that the state variable `_operatorApprovals` is written to. Since the rule states \"emit if always,\" we do not need to specify additional conditions for the emission of the event.\n\nHere is the JSON configuration for the rule verification:\n\n```json\n{\n    \"EmitVerify\": {\n        \"event\": \"ApprovalForAll\",\n        \"sv_cond\": {\n            \"type\": \"WrittenCondition\",\n            \"value\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"isApprovedForAll\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 0\n                    },\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 1\n                    }\n                ]\n            }\n        },\n        \"type\": \"EmitVerify\"\n    }\n}\n```\n\nExplanation:\n- **event**: Specifies the event name `ApprovalForAll` that must be emitted.\n- **sv_cond**: Specifies the condition under which the state variable is written. It uses a `WrittenCondition` to check that the `_operatorApprovals` state variable is written to.\n  - **value**: Uses a `StateVarSelector` to select the `_operatorApprovals` state variable, anchored by the function `isApprovedForAll`.\n  - **keys**: Specifies the keys used in the mapping. It uses `FuncParamSelector` to select the function parameters at index 0 (owner) and index 1 (operator) which correspond to the mapping keys in `_operatorApprovals`.\n- **type**: Specifies the type of verification, which is `EmitVerify`.\n\nThis configuration ensures that the `ApprovalForAll` event is verified to be emitted whenever the `setApprovalForAll` function is called, in line with the rule specified."
        },
        {
            "rule": "The function `getApproved(uint256 _tokenId)` returns the address that has been authorized to manage a specific non-fungible token (NFT) identified by `_tokenId`. If no address has been authorized for this particular NFT, the function will return a special value known as the zero address, which effectively means that no approval has been granted. This function is used to check which address, if any, has the permission to handle transactions involving the specified NFT, such as transferring it.",
            "type": "semantic_return",
            "interface": "function getApproved(uint256 _tokenId) external view returns (address)"
        },
        {
            "rule": " throw if _tokenId is not a valid NFT",
            "type": "throw",
            "interface": "function getApproved(uint256 _tokenId) external view returns (address)",
            "sym": {
                "ThrowVerify": {
                    "type": "ThrowVerify",
                    "cond": {
                        "type": "CompCondition",
                        "left": {
                            "type": "StateVarSelector",
                            "anchor_fn": "ownerOf",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 0
                                }
                            ]
                        },
                        "right": {
                            "type": "ConstantSelector",
                            "value": "0x0000000000000000000000000000000000000000"
                        },
                        "op": "eq"
                    },
                    "op": "throw"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification, we need to ensure that the function `getApproved(uint256 _tokenId)` throws an error if `_tokenId` is not a valid NFT. A valid NFT, in this context, is one that has an owner, which can be checked using the `ownerOf` function's state variable `_owners`.\n\nThe rule should verify that the `_owners` mapping at the index of `_tokenId` does not equal the zero address (indicating no owner and thus an invalid NFT). If it equals the zero address, the function should throw.\n\nHere is the JSON configuration for this rule:\n\n```json\n{\n    \"ThrowVerify\": {\n        \"type\": \"ThrowVerify\",\n        \"cond\": {\n            \"type\": \"CompCondition\",\n            \"left\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"ownerOf\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 0\n                    }\n                ]\n            },\n            \"right\": {\n                \"type\": \"ConstantSelector\",\n                \"value\": \"0x0000000000000000000000000000000000000000\"\n            },\n            \"op\": \"eq\"\n        },\n        \"op\": \"throw\"\n    }\n}\n```\n\nExplanation:\n- **ThrowVerify**: This object specifies that the condition inside it should lead to a throw if true.\n- **cond**: This is a comparison condition.\n  - **left**: This selects the state variable `_owners` from the `ownerOf` function, indexed by the first function parameter (`_tokenId`).\n  - **right**: This is a constant selector that specifies the zero address, which represents no owner.\n  - **op**: The operation `eq` checks for equality between the left and right values.\n- **op**: The operation `throw` specifies that the function should throw if the condition is true, i.e., if the `_tokenId` does not have a valid owner (owner address is zero).\n\nThis configuration ensures that `getApproved(uint256 _tokenId)` will throw an error if `_tokenId` is not associated with a valid owner, enforcing the rule that `_tokenId` must be a valid NFT."
        },
        {
            "rule": "The function `isApprovedForAll(address _owner, address _operator)` checks if a specific address, referred to as `_operator`, is authorized to manage all non-fungible tokens (NFTs) owned by another address, `_owner`. The function returns a boolean value: `true` if the `_operator` is indeed authorized to act on behalf of the `_owner` for all their NFTs, and `false` if the `_operator` does not have such authorization.",
            "type": "semantic_return",
            "interface": "function isApprovedForAll(address _owner, address _operator) external view returns (bool)"
        },
        {
            "rule": "emit 'Transfer'",
            "type": "emit",
            "interface": "event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);",
            "if": {
                "if": "ownership of any NFT changes by any mechanism",
                "arg_rules": [],
                "emit": [
                    "Transfer"
                ]
            },
            "sym": {
                "EmitVerify": {
                    "event": "Transfer",
                    "sv_cond": {
                        "type": "WrittenCondition",
                        "value": {
                            "type": "StateVarSelector",
                            "anchor_fn": "ownerOf",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 0
                                }
                            ]
                        }
                    },
                    "type": "EmitVerify"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification based on the provided schema and the rule \"emit 'Transfer' if 'ownership of any NFT changes by any mechanism'\", we need to focus on the state variable that directly reflects the ownership of an NFT. The most relevant state variable for this purpose is `_owners` from the `ownerOf` function, which maps a token ID to an owner address.\n\nGiven the rule, we need to verify that the `Transfer` event is emitted whenever there is a change in the `_owners` mapping. Here is the JSON configuration for this rule:\n\n```json\n{\n    \"EmitVerify\": {\n        \"event\": \"Transfer\",\n        \"sv_cond\": {\n            \"type\": \"WrittenCondition\",\n            \"value\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"ownerOf\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 0\n                    }\n                ]\n            },\n            \"change_type\": \"change\"\n        },\n        \"type\": \"EmitVerify\"\n    }\n}\n```\n\nExplanation:\n- **event**: Specifies the event that must be emitted, which is `Transfer`.\n- **sv_cond**: Specifies the condition under which the event should be emitted. It uses a `WrittenCondition` to check if the state variable `_owners` is written to.\n  - **value**: This is a `StateVarSelector` pointing to the `_owners` mapping in the `ownerOf` function. The key for this mapping is the token ID, which is selected using a `FuncParamSelector` at index 0 (assuming the first parameter of the function that modifies the ownership would be the token ID).\n  - **change_type**: Set to \"change\" to indicate that any change (either a new assignment or an update) in the mapping should trigger the condition.\n- **type**: Specifies the type of verification, which is `EmitVerify`.\n\nThis configuration ensures that the `Transfer` event must be emitted whenever there is a change in the ownership of any NFT, as indicated by a write operation to the `_owners` mapping."
        },
        {
            "rule": "emit 'Transfer'",
            "type": "emit",
            "interface": "event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);",
            "if": {
                "if": "NFTs are created",
                "arg_rules": [
                    {
                        "arg": 0,
                        "rule": "_from MUST be 0"
                    }
                ],
                "emit": [
                    "Transfer"
                ]
            },
            "sym": {
                "EmitVerify": {
                    "event": "Transfer",
                    "sv_cond": {
                        "type": "WrittenCondition",
                        "value": {
                            "type": "StateVarSelector",
                            "anchor_fn": "balanceOf",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 1
                                }
                            ]
                        },
                        "change_type": "token_creation"
                    },
                    "arg_verifiers": [
                        {
                            "type": "ArgVerify",
                            "arg_index": 0,
                            "expected_value": {
                                "value": {
                                    "type": "ConstantSelector",
                                    "value": "0"
                                }
                            }
                        }
                    ],
                    "type": "EmitVerify"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification based on the provided schema and the rule description, we need to focus on the event `Transfer` and the condition that it should be emitted when NFTs are created, with the `_from` argument being `0`.\n\nGiven the rule:\n- Emit `Transfer` if NFTs are created.\n- `_from` MUST be `0`.\n\nWe can infer that NFT creation can be detected by an increase in the balance of the `_to` address in the `balanceOf` mapping. This is because when a new NFT is created, it is typically assigned to an owner, which increases their balance.\n\nHere's the JSON configuration for this rule:\n\n```json\n{\n    \"EmitVerify\": {\n        \"event\": \"Transfer\",\n        \"sv_cond\": {\n            \"type\": \"WrittenCondition\",\n            \"value\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"balanceOf\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 1\n                    }\n                ]\n            },\n            \"change_type\": \"increase\"\n        },\n        \"arg_verifiers\": [\n            {\n                \"type\": \"ArgVerify\",\n                \"arg_index\": 0,\n                \"expected_value\": {\n                    \"value\": {\n                        \"type\": \"ConstantSelector\",\n                        \"value\": \"0\"\n                    }\n                }\n            }\n        ],\n        \"type\": \"EmitVerify\"\n    }\n}\n```\n\nExplanation:\n- **event**: Specifies the event name `Transfer` that needs to be verified.\n- **sv_cond**: Specifies the condition under which the state variable is written. It checks for an increase in the `_balances` mapping, which is linked to the `_to` address (second argument of the `Transfer` event).\n  - **StateVarSelector**: Points to the `balanceOf` function's state variable `_balances` and uses the second argument of the `Transfer` event as the key.\n- **arg_verifiers**: Contains the rules for verifying the arguments of the event.\n  - **ArgVerify** for `_from` (index 0) checks that it must be `0`.\n- **type**: Specifies the type of verification, which is `EmitVerify`.\n\nThis configuration ensures that the `Transfer` event is only considered valid if it corresponds to the creation of an NFT (detected by an increase in balance) and the `_from` address is `0`."
        },
        {
            "rule": "emit 'Transfer'",
            "type": "emit",
            "interface": "event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);",
            "if": {
                "if": "NFTs are destroyed",
                "arg_rules": [
                    {
                        "arg": 1,
                        "rule": "_to MUST be 0"
                    }
                ],
                "emit": [
                    "Transfer"
                ]
            },
            "sym": {
                "EmitVerify": {
                    "type": "EmitVerify",
                    "event": "Transfer",
                    "sv_cond": {
                        "type": "WrittenCondition",
                        "value": {
                            "type": "StateVarSelector",
                            "anchor_fn": "balanceOf",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 0
                                }
                            ]
                        },
                        "change_type": "token_burn"
                    },
                    "arg_verifiers": [
                        {
                            "type": "ArgVerify",
                            "arg_index": 1,
                            "expected_value": {
                                "value": {
                                    "type": "ConstantSelector",
                                    "value": "0"
                                }
                            }
                        }
                    ]
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification based on the provided schema and the rule description, we need to focus on the event `Transfer` and the condition that it should be emitted when NFTs are destroyed, with the requirement that the `_to` argument must be `0`.\n\nGiven the rule and the schema, we can construct the JSON as follows:\n\n1. **EmitVerify**: This is the main object that specifies the conditions under which the `Transfer` event should be emitted.\n2. **sv_cond**: This specifies the condition related to state variable changes. Since NFTs are destroyed, we expect the balance of the `_from` address to decrease.\n3. **arg_verifiers**: This specifies the conditions for the arguments of the event, particularly that `_to` must be `0`.\n\nHere is the JSON configuration:\n\n```json\n{\n    \"EmitVerify\": {\n        \"type\": \"EmitVerify\",\n        \"event\": \"Transfer\",\n        \"sv_cond\": {\n            \"type\": \"WrittenCondition\",\n            \"value\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"balanceOf\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 0\n                    }\n                ]\n            },\n            \"change_type\": \"decrease\"\n        },\n        \"arg_verifiers\": [\n            {\n                \"type\": \"ArgVerify\",\n                \"arg_index\": 1,\n                \"expected_value\": {\n                    \"value\": {\n                        \"type\": \"ConstantSelector\",\n                        \"value\": \"0\"\n                    }\n                }\n            }\n        ]\n    }\n}\n```\n\n### Explanation:\n- **EmitVerify**: The main object that defines the verification for the `Transfer` event emission.\n- **event**: Specifies the name of the event to verify, which is `Transfer`.\n- **sv_cond**: Defines the condition related to state variable changes. We use `WrittenCondition` to specify that the `_balances` mapping (accessed via the `balanceOf` function) should have a decrease for the address from which the NFT is transferred (`_from`).\n- **arg_verifiers**: An array of conditions for the event arguments. Here, we specify that the second argument (`_to`, at index 1) must be `0` to indicate that the NFT is being destroyed (transferred to a null address).\n- **value** under `arg_verifiers`: Uses a `ConstantSelector` to specify the constant value `0`.\n\nThis JSON configuration aligns with the rule that the `Transfer` event should be emitted when an NFT is destroyed, ensuring that the `_to` address is `0`."
        },
        {
            "rule": "emit 'Transfer'",
            "type": "emit",
            "interface": "event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);",
            "if": {
                "if": "during contract creation, any number of NFTs may be created and assigned",
                "arg_rules": [],
                "emit": []
            },
            "sym": {
                "EmitVerify": {
                    "event": "Transfer",
                    "sv_cond": {
                        "type": "WrittenCondition",
                        "value": {
                            "anchor_fn": "ownerOf",
                            "type": "StateVarSelector"
                        }
                    },
                    "type": "EmitVerify",
                    "within_call_fn": null
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification, we need to focus on the event `Transfer` and the condition specified: \"during contract creation, any number of NFTs may be created and assigned\". This implies that the `Transfer` event should be emitted when NFTs are created and assigned to an owner, typically from a zero address (indicating creation).\n\nGiven the rule and the possible anchor functions, the most relevant state variable for tracking NFT creation and assignment is `_owners` from the `ownerOf` function, which maps a token ID to an owner address. The creation of an NFT can be inferred when this mapping is written to for the first time for a token ID, typically setting it from an uninitialized state (zero address) to a non-zero address.\n\nHere is the JSON configuration for the rule verification:\n\n```json\n{\n    \"EmitVerify\": {\n        \"event\": \"Transfer\",\n        \"sv_cond\": {\n            \"type\": \"WrittenCondition\",\n            \"value\": {\n                \"anchor_fn\": \"ownerOf\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 0\n                    }\n                ],\n                \"type\": \"StateVarSelector\"\n            },\n            \"change_type\": \"change\",\n            \"written_cnt\": \"one\"\n        },\n        \"type\": \"EmitVerify\",\n        \"within_call_fn\": null\n    }\n}\n```\n\nExplanation:\n- **event**: Specifies the event to verify, which is `Transfer`.\n- **sv_cond**: Specifies the condition related to state variable changes.\n  - **type**: Indicates this is a condition based on a state variable write.\n  - **value**: Specifies the state variable to monitor.\n    - **anchor_fn**: The function associated with the state variable, which is `ownerOf`.\n    - **keys**: Specifies the keys used in the state variable. Here, it uses the first function parameter (token ID) to index into the `_owners` mapping.\n  - **change_type**: Indicates the type of change to monitor, which is any change (`change`).\n  - **written_cnt**: Specifies that the condition should check for the first write to this state variable.\n- **type**: Specifies the type of verification, which is an event emission verification.\n- **within_call_fn**: Not specified, as the rule does not restrict the emission to specific function calls.\n\nThis configuration ensures that the `Transfer` event is verified for emission when an NFT is created and assigned during contract creation, as indicated by the first-time write to the `_owners` mapping for a token ID."
        },
        {
            "rule": "emit '['Approval']' if `msg.sender` is the current NFT owner or an authorized operator of the current owner",
            "type": "emit",
            "interface": "function approve(address _approved, uint256 _tokenId) external payable",
            "sym": {
                "EmitVerify": {
                    "event": "Approval",
                    "sv_cond": {
                        "type": "WrittenCondition",
                        "value": {
                            "type": "StateVarSelector",
                            "anchor_fn": "getApproved",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 1
                                }
                            ]
                        }
                    },
                    "cond": {
                        "type": "LogicCondition",
                        "op": "or",
                        "conds": [
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "StateVarSelector",
                                    "anchor_fn": "ownerOf",
                                    "keys": [
                                        {
                                            "type": "FuncParamSelector",
                                            "index": 1
                                        }
                                    ]
                                },
                                "right": {
                                    "type": "ConstantSelector",
                                    "value": "msg.sender"
                                },
                                "op": "eq"
                            },
                            {
                                "type": "CompCondition",
                                "left": {
                                    "type": "StateVarSelector",
                                    "anchor_fn": "isApprovedForAll",
                                    "keys": [
                                        {
                                            "type": "StateVarSelector",
                                            "anchor_fn": "ownerOf",
                                            "keys": [
                                                {
                                                    "type": "FuncParamSelector",
                                                    "index": 1
                                                }
                                            ]
                                        },
                                        {
                                            "type": "ConstantSelector",
                                            "value": "msg.sender"
                                        }
                                    ]
                                },
                                "right": {
                                    "type": "ConstantSelector",
                                    "value": true
                                },
                                "op": "eq"
                            }
                        ]
                    },
                    "type": "EmitVerify"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification of the `approve` function, we need to ensure that the `Approval` event is emitted if `msg.sender` is the current NFT owner or an authorized operator of the current owner. We will use the anchor functions `ownerOf`, `isApprovedForAll`, and the `msg.sender` to construct the conditions.\n\nHere's the JSON configuration for the rule verification:\n\n```json\n{\n    \"EmitVerify\": {\n        \"event\": \"Approval\",\n        \"sv_cond\": {\n            \"type\": \"WrittenCondition\",\n            \"value\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"getApproved\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 1\n                    }\n                ]\n            }\n        },\n        \"cond\": {\n            \"type\": \"LogicCondition\",\n            \"op\": \"or\",\n            \"conds\": [\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"StateVarSelector\",\n                        \"anchor_fn\": \"ownerOf\",\n                        \"keys\": [\n                            {\n                                \"type\": \"FuncParamSelector\",\n                                \"index\": 1\n                            }\n                        ]\n                    },\n                    \"right\": {\n                        \"type\": \"ConstantSelector\",\n                        \"value\": \"msg.sender\"\n                    },\n                    \"op\": \"eq\"\n                },\n                {\n                    \"type\": \"CompCondition\",\n                    \"left\": {\n                        \"type\": \"StateVarSelector\",\n                        \"anchor_fn\": \"isApprovedForAll\",\n                        \"keys\": [\n                            {\n                                \"type\": \"StateVarSelector\",\n                                \"anchor_fn\": \"ownerOf\",\n                                \"keys\": [\n                                    {\n                                        \"type\": \"FuncParamSelector\",\n                                        \"index\": 1\n                                    }\n                                ]\n                            },\n                            {\n                                \"type\": \"ConstantSelector\",\n                                \"value\": \"msg.sender\"\n                            }\n                        ]\n                    },\n                    \"right\": {\n                        \"type\": \"ConstantSelector\",\n                        \"value\": true\n                    },\n                    \"op\": \"eq\"\n                }\n            ]\n        },\n        \"type\": \"EmitVerify\"\n    }\n}\n```\n\nExplanation:\n1. **Event**: We specify that the event to verify is `Approval`.\n2. **sv_cond**: This condition checks that the `getApproved` state variable is written to. It uses the token ID from the function parameter to index into the `_tokenApprovals` mapping.\n3. **cond**: This is a logical condition that combines two comparison conditions with an \"or\" operator:\n   - The first condition checks if the `msg.sender` is equal to the owner of the token (using the `ownerOf` function).\n   - The second condition checks if `msg.sender` is an approved operator for the owner of the token (using the `isApprovedForAll` function).\n\nThis configuration ensures that the `Approval` event is emitted only if the conditions specified are met, aligning with the rule that `msg.sender` must be the current NFT owner or an authorized operator."
        },
        {
            "rule": "the approved address for that NFT (if any) is reset to none",
            "type": "assign",
            "interface": "event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)",
            "sym": {
                "StateAssignVerify": {
                    "type": "StateAssignVerify",
                    "event":"Transfer",
                    "state": {
                        "type": "StateVarSelector",
                        "anchor_fn": "getApproved",
                        "keys": [
                            {
                                "type": "EventParamSelector",
                                "index": 2
                            }
                        ]
                    },
                    "value": {
                        "type": "NoneValueSelector"
                    },
                    "op": "overwrite"
                }
            },
            "sym_debug": "To generate the JSON for the rule verification based on the provided schema and the rule description, we need to focus on the `getApproved` function and its associated state variable `_tokenApprovals`. The rule states that the approved address for an NFT is reset to none, which implies setting the value of `_tokenApprovals` for a specific token ID to `address(0)` (the zero address in Solidity, representing 'none').\n\nHere's the JSON configuration for the rule verification:\n\n```json\n{\n    \"StateAssignVerify\": {\n        \"type\": \"StateAssignVerify\",\n        \"op\": \"overwrite\",\n        \"state\": {\n            \"type\": \"StateVarSelector\",\n            \"anchor_fn\": \"getApproved\",\n            \"keys\": [\n                {\n                    \"type\": \"FuncParamSelector\",\n                    \"index\": 0\n                }\n            ]\n        },\n        \"value\": {\n            \"type\": \"FuncParamSelector\",\n            \"index\": 1\n        }\n    }\n}\n```\n\nExplanation:\n- **StateAssignVerify**: This is the main object that defines the operation to be performed.\n- **type**: Specifies the type of operation, which is `StateAssignVerify`.\n- **op**: Specifies the operation to be performed on the state variable, which is `overwrite` in this case.\n- **state**:\n  - **type**: Specifies the selector type, which is `StateVarSelector`.\n  - **anchor_fn**: Specifies the function associated with the state variable, which is `getApproved`.\n  - **keys**: Specifies the keys used to access the state variable. Here, it uses a `FuncParamSelector` to select the first function parameter (assuming the token ID is the first parameter in `getApproved`).\n- **value**:\n  - **type**: Specifies the selector type, which is `FuncParamSelector`.\n  - **index**: Specifies the index of the function parameter that contains the new value to be assigned. In this case, it should be the parameter that represents the new approved address, which should be set to `address(0)`.\n\nNote: The JSON provided assumes that the function `getApproved` takes a token ID as its first parameter and that the new value (address to be set) is passed as the second parameter. If the function signature or logic differs, adjustments may be needed. Also, the JSON schema assumes that the function parameters are correctly indexed and that the second parameter can be used to set the new value, which should be `address(0)`. If the function does not take a second parameter for setting a new value, this schema will not be applicable directly and would need modification to fit the actual function signature."
        },
        {
            "rule": "emit 'Approval'",
            "type": "emit",
            "interface": "event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);",
            "if": {
                "if": "the approved address for an NFT is changed or reaffirmed",
                "alternative_events": [
                    {
                        "name": "Transfer"
                    }
                ]
            },
            "sym": {"EmitVerify": {
                    "event": "Approval",
                    "sv_cond": {
                        "type": "WrittenCondition",
                        "value": {
                            "type": "StateVarSelector",
                            "anchor_fn": "getApproved",
                            "keys": [
                                {
                                    "type": "EventParamSelector",
                                    "index": 2
                                }
                            ]
                        }
                    },
                    "cond": {
                        "type": "CompCondition",
                        "left": {
                            "type": "StateVarSelector",
                            "anchor_fn": "getApproved",
                            "keys": [
                                {
                                    "type": "EventParamSelector",
                                    "index": 2
                                }
                            ]
                        },
                        "right": {
                            "type": "EventParamSelector",
                            "index": 1
                        },
                        "op": "not_eq"
                    },
                    "alternative_events": [
                        "Transfer"
                    ],
                    "type": "EmitVerify"
                }
            }

        },
        {
            "rule": "emit 'Approval'",
            "type": "emit",
            "interface": "event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);",
            "if": {
                "if": "a Transfer event emits",
                "arg_rules": [
                    {
                        "arg": 1,
                        "rule": "The argument _approved MUST be set to none."
                    }
                ],
                "emit": [
                    "Approval"
                ]
            },
            "sym": {
                "EmitVerify": {
                    "event": "Approval",
                    "sv_cond": {
                        "type": "WrittenCondition",
                        "value": {
                            "type": "StateVarSelector",
                            "anchor_fn": "getApproved",
                            "keys": [
                                {
                                    "type": "FuncParamSelector",
                                    "index": 2
                                }
                            ]
                        }
                    },
                    "arg_verifiers": [
                        {
                            "type": "ArgVerify",
                            "arg_index": 1,
                            "expected_value": {
                                "value": {
                                    "type": "ConstantSelector",
                                    "value": "none"
                                },
                                "cond": {
                                    "type": "CompCondition",
                                    "left": {
                                        "type": "FuncParamSelector",
                                        "index": 1
                                    },
                                    "right": {
                                        "type": "ConstantSelector",
                                        "value": "none"
                                    },
                                    "op": "eq"
                                }
                            }
                        }
                    ],
                    "type": "EmitVerify"
                }
            },
            "sym_debug": "To generate the JSON configuration for the rule verification based on the provided schema and the rule description, we need to focus on the event `Approval` and its conditions related to the `Transfer` event. The rule specifies that the `Approval` event should be emitted if a `Transfer` event emits with the condition that the `_approved` argument in the `Transfer` event must be set to `none`.\n\nHere's the JSON configuration for this rule:\n\n```json\n{\n    \"EmitVerify\": {\n        \"event\": \"Approval\",\n        \"sv_cond\": {\n            \"type\": \"WrittenCondition\",\n            \"value\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"getApproved\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 2\n                    }\n                ]\n            }\n        },\n        \"arg_verifiers\": [\n            {\n                \"type\": \"ArgVerify\",\n                \"arg_index\": 1,\n                \"expected_value\": {\n                    \"value\": {\n                        \"type\": \"ConstantSelector\",\n                        \"value\": \"none\"\n                    },\n                    \"cond\": {\n                        \"type\": \"CompCondition\",\n                        \"left\": {\n                            \"type\": \"FuncParamSelector\",\n                            \"index\": 1\n                        },\n                        \"right\": {\n                            \"type\": \"ConstantSelector\",\n                            \"value\": \"none\"\n                        },\n                        \"op\": \"eq\"\n                    }\n                }\n            }\n        ],\n        \"type\": \"EmitVerify\"\n    }\n}\n```\n\nExplanation:\n1. **event**: Specifies the event to verify, which is `Approval`.\n2. **sv_cond**: Specifies the condition related to state variable changes. Here, it checks the `_tokenApprovals` mapping, which is related to the `getApproved` function. The key for this mapping is the token ID, which is the third argument (`index: 2`) in the `Transfer` event.\n3. **arg_verifiers**: Contains the rules for argument verification. It checks that the second argument (`arg_index: 1`) of the `Approval` event, which corresponds to `_approved`, must be set to `none`.\n4. **type**: Specifies the type of verification, which is `EmitVerify`.\n\nThis configuration ensures that the `Approval` event is emitted following the specified conditions when a `Transfer` event occurs."
        },
        {
            "rule": "emit 'ApprovalForAll'",
            "type": "emit",
            "interface": "event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);",
            "if": {
                "if": "an operator is enabled or disabled for an owner",
                "arg_rules": [
                    {
                        "arg": 0,
                        "rule": "The argument _owner MUST be the address of the NFT owner"
                    },
                    {
                        "arg": 1,
                        "rule": "The argument _operator MUST be the address of the operator"
                    },
                    {
                        "arg": 2,
                        "rule": "The argument _approved MUST be set to true if the operator is enabled, false if disabled"
                    }
                ],
                "emit": [
                    "ApprovalForAll"
                ]
            },
            "sym": {
                "EmitVerify": {
                    "event": "ApprovalForAll",
                    "sv_cond": {
                        "type": "WrittenCondition",
                        "value": {
                            "type": "StateVarSelector",
                            "anchor_fn": "isApprovedForAll"
                        }
                    },
                    "type": "EmitVerify"
                }
            },
            "sym_debug": "To generate the JSON verification schema for the rule associated with the `ApprovalForAll` event, we need to consider the conditions under which this event is emitted. The event is emitted when an operator is enabled or disabled for an owner. This involves a change in the `_operatorApprovals` mapping state variable.\n\nHere's the JSON schema for verifying the rule:\n\n```json\n{\n    \"EmitVerify\": {\n        \"event\": \"ApprovalForAll\",\n        \"sv_cond\": {\n            \"type\": \"WrittenCondition\",\n            \"value\": {\n                \"type\": \"StateVarSelector\",\n                \"anchor_fn\": \"isApprovedForAll\",\n                \"keys\": [\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 0\n                    },\n                    {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 1\n                    }\n                ]\n            },\n            \"change_type\": \"change\"\n        },\n        \"arg_verifiers\": [\n            {\n                \"type\": \"ArgVerify\",\n                \"arg_index\": 0,\n                \"expected_value\": {\n                    \"value\": {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 0\n                    }\n                }\n            },\n            {\n                \"type\": \"ArgVerify\",\n                \"arg_index\": 1,\n                \"expected_value\": {\n                    \"value\": {\n                        \"type\": \"FuncParamSelector\",\n                        \"index\": 1\n                    }\n                }\n            },\n            {\n                \"type\": \"ArgVerify\",\n                \"arg_index\": 2,\n                \"expected_value\": {\n                    \"value\": {\n                        \"type\": \"StateVarSelector\",\n                        \"anchor_fn\": \"isApprovedForAll\",\n                        \"keys\": [\n                            {\n                                \"type\": \"FuncParamSelector\",\n                                \"index\": 0\n                            },\n                            {\n                                \"type\": \"FuncParamSelector\",\n                                \"index\": 1\n                            }\n                        ]\n                    }\n                }\n            }\n        ],\n        \"type\": \"EmitVerify\"\n    }\n}\n```\n\nExplanation:\n- **event**: Specifies the event name `ApprovalForAll` that needs to be verified.\n- **sv_cond**: Specifies the condition related to the state variable `_operatorApprovals` being written to. It uses a `WrittenCondition` to check for any change (`change_type: \"change\"`) in the mapping for the specific owner and operator addresses.\n- **arg_verifiers**: An array of argument verifiers ensuring that:\n  - The first argument (`_owner`) matches the first function parameter.\n  - The second argument (`_operator`) matches the second function parameter.\n  - The third argument (`_approved`) matches the current state of the mapping `_operatorApprovals` for the given owner and operator.\n  \nThis schema ensures that the `ApprovalForAll` event is emitted correctly according to the specified conditions and arguments."
        }
    ]
}