{
    "results": [
        {
            "rule": "balanceOf(address):function balanceOf(address _owner) external view returns (uint256) throw if _owner is the zero address",
            "violated": true
        },
        {
            "rule": "ownerOf(uint256):function ownerOf(uint256 _tokenId) external view returns (address) throw if NFTs assigned to zero address",
            "violated": true
        },
        {
            "rule": "transferFrom(address,address,uint256):function transferFrom(address _from, address _to, uint256 _tokenId) external payable throw if `msg.sender` is not the current owner, an authorized operator, or the approved address for this NFT",
            "violated": true
        },
        {
            "rule": "transferFrom(address,address,uint256):function transferFrom(address _from, address _to, uint256 _tokenId) external payable throw if `_from` is not the current owner",
            "violated": false
        },
        {
            "rule": "transferFrom(address,address,uint256):function transferFrom(address _from, address _to, uint256 _tokenId) external payable throw if `_to` is the zero address",
            "violated": false
        },
        {
            "rule": "transferFrom(address,address,uint256):function transferFrom(address _from, address _to, uint256 _tokenId) external payable throw if `_tokenId` is not a valid NFT",
            "violated": false
        },
        {
            "rule": "transferFrom(address,address,uint256):function transferFrom(address _from, address _to, uint256 _tokenId) external payableemit '['Transfer']' if msg.sender is the current owner, an authorized operator, or the approved address for this NFT, `_from` is the current owner, `_to` is not the zero address, and `_tokenId` is a valid NFT",
            "violated": true
        },
        {
            "rule": "approve(address,uint256):function approve(address _approved, uint256 _tokenId) external payable throw if `msg.sender` is not the current NFT owner and not an authorized operator of the current owner",
            "violated": false
        },
        {
            "rule": "approve(address,uint256):function approve(address _approved, uint256 _tokenId) external payableemit '['Approval']' if `msg.sender` is the current NFT owner or an authorized operator of the current owner",
            "violated": true
        },
        {
            "rule": "getApproved(uint256):function getApproved(uint256 _tokenId) external view returns (address) throw if _tokenId is not a valid NFT",
            "violated": true
        },
        {
            "rule": "totalSupply():event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "balanceOf(address):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "ownerOf(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "tokenMetadata(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "approve(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "transferFrom(address,address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "transfer(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "tokenOfOwnerByIndex(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "getOwnerTokens(address):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "implementsERC721():event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "getApproved(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "totalSupply():event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "balanceOf(address):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "ownerOf(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "tokenMetadata(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "approve(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "transferFrom(address,address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "transfer(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "tokenOfOwnerByIndex(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "getOwnerTokens(address):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "implementsERC721():event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "getApproved(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "totalSupply():event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "balanceOf(address):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "ownerOf(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "tokenMetadata(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "approve(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "transferFrom(address,address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "transfer(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "tokenOfOwnerByIndex(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "getOwnerTokens(address):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "implementsERC721():event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "getApproved(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "totalSupply():event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "balanceOf(address):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "ownerOf(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "tokenMetadata(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "approve(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": true
        },
        {
            "rule": "transferFrom(address,address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "transfer(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "tokenOfOwnerByIndex(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "getOwnerTokens(address):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "implementsERC721():event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "getApproved(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "totalSupply():event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "balanceOf(address):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "ownerOf(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "tokenMetadata(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "approve(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": true
        },
        {
            "rule": "transferFrom(address,address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "transfer(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "tokenOfOwnerByIndex(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "getOwnerTokens(address):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "implementsERC721():event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "getApproved(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);emit 'Transfer'",
            "violated": false
        },
        {
            "rule": "totalSupply():event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT (if any) is reset to none",
            "violated": false
        },
        {
            "rule": "balanceOf(address):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT (if any) is reset to none",
            "violated": false
        },
        {
            "rule": "ownerOf(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT (if any) is reset to none",
            "violated": false
        },
        {
            "rule": "tokenMetadata(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT (if any) is reset to none",
            "violated": true
        },
        {
            "rule": "approve(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT (if any) is reset to none",
            "violated": true
        },
        {
            "rule": "transferFrom(address,address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT (if any) is reset to none",
            "violated": false
        },
        {
            "rule": "transfer(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT (if any) is reset to none",
            "violated": false
        },
        {
            "rule": "tokenOfOwnerByIndex(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT (if any) is reset to none",
            "violated": false
        },
        {
            "rule": "getOwnerTokens(address):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT (if any) is reset to none",
            "violated": false
        },
        {
            "rule": "implementsERC721():event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT (if any) is reset to none",
            "violated": false
        },
        {
            "rule": "getApproved(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT (if any) is reset to none",
            "violated": true
        },
        {
            "rule": "totalSupply():event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "balanceOf(address):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "ownerOf(uint256):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "tokenMetadata(uint256):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "approve(address,uint256):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": true
        },
        {
            "rule": "transferFrom(address,address,uint256):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "transfer(address,uint256):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "tokenOfOwnerByIndex(address,uint256):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "getOwnerTokens(address):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "implementsERC721():event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "getApproved(uint256):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "totalSupply():event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "balanceOf(address):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "ownerOf(uint256):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "tokenMetadata(uint256):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "approve(address,uint256):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "transferFrom(address,address,uint256):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "transfer(address,uint256):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "tokenOfOwnerByIndex(address,uint256):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "getOwnerTokens(address):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "implementsERC721():event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "getApproved(uint256):event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);emit 'Approval'",
            "violated": false
        },
        {
            "rule": "totalSupply():event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT is reset to none",
            "violated": true
        },
        {
            "rule": "balanceOf(address):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT is reset to none",
            "violated": true
        },
        {
            "rule": "ownerOf(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT is reset to none",
            "violated": true
        },
        {
            "rule": "tokenMetadata(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT is reset to none",
            "violated": true
        },
        {
            "rule": "approve(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT is reset to none",
            "violated": true
        },
        {
            "rule": "transferFrom(address,address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT is reset to none",
            "violated": false
        },
        {
            "rule": "transfer(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT is reset to none",
            "violated": false
        },
        {
            "rule": "tokenOfOwnerByIndex(address,uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT is reset to none",
            "violated": true
        },
        {
            "rule": "getOwnerTokens(address):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT is reset to none",
            "violated": true
        },
        {
            "rule": "implementsERC721():event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT is reset to none",
            "violated": true
        },
        {
            "rule": "getApproved(uint256):event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId)the approved address for that NFT is reset to none",
            "violated": true
        },
        {
            "rule": "totalSupply():event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);emit 'ApprovalForAll'",
            "violated": false
        },
        {
            "rule": "balanceOf(address):event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);emit 'ApprovalForAll'",
            "violated": false
        },
        {
            "rule": "ownerOf(uint256):event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);emit 'ApprovalForAll'",
            "violated": false
        },
        {
            "rule": "tokenMetadata(uint256):event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);emit 'ApprovalForAll'",
            "violated": false
        },
        {
            "rule": "approve(address,uint256):event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);emit 'ApprovalForAll'",
            "violated": false
        },
        {
            "rule": "transferFrom(address,address,uint256):event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);emit 'ApprovalForAll'",
            "violated": true
        },
        {
            "rule": "transfer(address,uint256):event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);emit 'ApprovalForAll'",
            "violated": false
        },
        {
            "rule": "tokenOfOwnerByIndex(address,uint256):event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);emit 'ApprovalForAll'",
            "violated": false
        },
        {
            "rule": "getOwnerTokens(address):event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);emit 'ApprovalForAll'",
            "violated": false
        },
        {
            "rule": "implementsERC721():event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);emit 'ApprovalForAll'",
            "violated": false
        },
        {
            "rule": "getApproved(uint256):event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);emit 'ApprovalForAll'",
            "violated": false
        }
    ]
}